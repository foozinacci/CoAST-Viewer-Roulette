<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CoAST Viewer Slot Machine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;800&display=swap');

    :root{
      --bg:#15100c;
      --panel:#0b0a09;
      --border:#3f2f19;
      --accent:#f9fafb;
      --blue:#38bdf8;
      --red:#fb4b4b;
      --green:#22c55e;
      --gold:#facc15;
      --text:#fef9c3;
      --muted:#d1bfa1;
      --danger:#f97373;
      --ok:#4ade80;
      --theme-color:#ffffff;
      --theme-glow:rgba(255,255,255,0.4);
      --gradient-border:linear-gradient(90deg, #ffffff, #e5e7eb, #d1d5db, #ffffff);
      --gradient-border-size:200%;
      --logo-ring-gradient:conic-gradient(from 0deg, #ffffff 0deg 60deg, transparent 60deg 120deg, #ffffff 120deg 180deg, transparent 180deg 240deg, #ffffff 240deg 300deg, transparent 300deg 360deg);
    }
    body.theme-white{
      --bg:#1f2937;
      --panel:#111827;
      --accent:#fefce8;
      --gold:#facc15;
      --blue:#60a5fa;
      --red:#f97373;
      --green:#4ade80;
      --text:#f9fafb;
      --muted:#e5e7eb;
      --theme-color:#fefce8;
      --theme-glow:rgba(254,252,232,0.6);
      --border:#fefce8;
    }
    body.theme-blue{
      --bg:#020617;
      --panel:#0f172a;
      --accent:#dbeafe;
      --blue:#93c5fd;
      --red:#fb4b4b;
      --green:#22c55e;
      --gold:#facc15;
      --text:#dbeafe;
      --muted:#cbd5e1;
      --theme-color:#93c5fd;
      --theme-glow:rgba(147,197,253,0.7);
      --border:#93c5fd;
    }
    body.theme-black{
      --bg:#1e1b29;
      --panel:#2d2838;
      --accent:#e9d5ff;
      --gold:#eab308;
      --blue:#c084fc;
      --red:#fb4b4b;
      --green:#22c55e;
      --text:#e9d5ff;
      --muted:#d8b4fe;
      --theme-color:#c084fc;
      --theme-glow:rgba(192,132,252,0.7);
      --border:#c084fc;
    }
    body.theme-red{
      --bg:#3f0f12;
      --panel:#1f0507;
      --accent:#fee2e2;
      --gold:#fb923c;
      --blue:#22d3ee;
      --red:#ef4444;
      --green:#22c55e;
      --text:#f9fafb;
      --muted:#fecaca;
      --theme-color:#ef4444;
      --theme-glow:rgba(239,68,68,0.6);
      --border:#ef4444;
    }
    body.theme-green{
      --bg:#022c22;
      --panel:#051b15;
      --accent:#dcfce7;
      --gold:#facc15;
      --blue:#38bdf8;
      --red:#fb4b4b;
      --green:#22c55e;
      --text:#ecfdf5;
      --muted:#a7f3d0;
      --theme-color:#22c55e;
      --theme-glow:rgba(34,197,94,0.6);
      --border:#22c55e;
    }
    /* Global scrollbar elimination */
    *{
      scrollbar-width:none; /* Firefox */
      -ms-overflow-style:none; /* IE/Edge */
    }
    *::-webkit-scrollbar{
      display:none; /* Chrome/Safari */
    }
    html,body{
      overflow:hidden; /* Prevent browser-level scrolling */
      height:100vh;
      width:100vw;
      margin:0;
      padding:0;
    }
    body.theme-gold{
      --bg:#1e1814;
      --panel:#2d2410;
      --accent:#fef9c3;
      --gold:#fcd34d;
      --blue:#60a5fa;
      --red:#fb4b4b;
      --green:#22c55e;
      --text:#fef9c3;
      --muted:#fde68a;
      --theme-color:#fcd34d;
      --theme-glow:rgba(252,211,77,0.8);
      --border:#fcd34d;
    }

    @keyframes gradientShift{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    @keyframes blackLayerShift{
      0%{background-position:100% 50%;}
      50%{background-position:0% 50%;}
      100%{background-position:100% 50%;}
    }

    @keyframes rotate{
      0%{transform:rotate(0deg);}
      100%{transform:rotate(360deg);}
    }

    @keyframes savePulse{
      0%{
        background:var(--theme-color);
        box-shadow:0 0 12px var(--theme-glow);
        transform:scale(1);
      }
      50%{
        background:var(--theme-color);
        box-shadow:0 0 16px var(--theme-glow);
        transform:scale(1.2);
      }
      100%{
        background:#4b5563;
        box-shadow:0 0 4px rgba(0,0,0,.8);
        transform:scale(1);
      }
    }

    @keyframes savePulseWUBRG{
      0%{
        background:linear-gradient(90deg, #fefce8, #38bdf8, #c084fc, #fb4b4b, #22c55e);
        box-shadow:0 0 12px rgba(250,204,21,0.8);
        transform:scale(1);
      }
      50%{
        background:linear-gradient(90deg, #fefce8, #38bdf8, #c084fc, #fb4b4b, #22c55e);
        box-shadow:0 0 16px rgba(250,204,21,0.9);
        transform:scale(1.2);
      }
      100%{
        background:#4b5563;
        box-shadow:0 0 4px rgba(0,0,0,.8);
        transform:scale(1);
      }
    }

    *{box-sizing:border-box;}
    html,body{
      margin:0;
      padding:0;
      overflow-x:hidden;
      width:100%;
    }
    body{
      font-family:'Cinzel',serif;
      background:
        /* Weathered texture overlay */
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(143,82,57,0.03) 2px, rgba(143,82,57,0.03) 4px),
        repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(143,82,57,0.03) 2px, rgba(143,82,57,0.03) 4px),
        /* Subtle noise/grain */
        radial-gradient(circle at 20% 30%, rgba(255,255,255,0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(0,0,0,0.15) 0%, transparent 50%),
        /* Base gradient with #8f5239 */
        radial-gradient(circle at top, #8f5239 0%, rgba(143,82,57,0.7) 30%, var(--bg) 60%, #000 100%);
      color:var(--text);
      display:flex;
      justify-content:center;
      min-height:100vh;
    }
    #app{
      width:100%;
      max-width:1200px;
      margin:8px;
      border-radius:18px;
      border:2px solid var(--border);
      background:linear-gradient(145deg,var(--bg) 0,var(--bg) 40%,#050816 100%);
      box-shadow:0 0 40px rgba(0,0,0,.8),0 0 30px var(--theme-glow),inset 0 0 20px var(--theme-glow);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }
    header{
      padding:12px 16px;
      border-bottom:2px solid var(--border);
      box-shadow:0 2px 12px var(--theme-glow);
    }
    .header-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      width:100%;
    }
    .header-spin-controls{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      flex-shrink:0;
    }
    .logo{
      width:110px;
      height:110px;
      overflow:visible;
      background:radial-gradient(circle, rgba(250,204,21,0.15) 0%, rgba(250,204,21,0.05) 70%, transparent 100%);
      background-clip:padding-box;
      border:3px solid transparent;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 0 20px rgba(250,204,21,0.2), inset 0 0 20px rgba(250,204,21,0.1);
      position:relative;
    }
    .logo::after{
      content:'';
      position:absolute;
      inset:-3px;
      border-radius:50%;
      padding:3px;
      background:var(--logo-ring-gradient, conic-gradient(from 0deg,
        var(--theme-color) 0deg 60deg,
        transparent 60deg 120deg,
        var(--theme-color) 120deg 180deg,
        transparent 180deg 240deg,
        var(--theme-color) 240deg 300deg,
        transparent 300deg 360deg));
      -webkit-mask:radial-gradient(farthest-side, transparent calc(100% - 3px), #fff calc(100% - 3px));
      mask:radial-gradient(farthest-side, transparent calc(100% - 3px), #fff calc(100% - 3px));
      pointer-events:none;
      animation:rotate 2s linear infinite;
      z-index:1;
    }
    .logo::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:50%;
      background:var(--bg);
      z-index:1;
    }
    .logo img{
      width:80%;
      height:80%;
      object-fit:contain;
      filter:none;
      position:relative;
      z-index:2;
    }
    .title-block{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      flex:1;
    }
    .title{
      font-size:22px;
      font-weight:700;
      letter-spacing:.08em;
      color:var(--gold);
      text-shadow:0 0 8px rgba(250,204,21,.4);
    }
    .subtitle{
      display:block;
      font-size:11px;
      color:var(--muted);
      letter-spacing:.06em;
      opacity:0.8;
    }
    .theme-toggle{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      margin-top:4px;
    }
    .theme-chip{
      width:30px;
      height:30px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.1);
      cursor:pointer;
      opacity:0.4;
      display:flex;
      align-items:center;
      justify-content:center;
      background-color:transparent;
      background-repeat:no-repeat;
      background-position:center;
      background-size:contain;
      color:transparent;
      text-indent:-9999px;
      filter:grayscale(100%) brightness(0.6);
      transform:scale(0.95);
      transition:all 0.2s ease;
    }
    .theme-chip.active{
      opacity:1;
      filter:grayscale(0%) brightness(1.1);
      border:2px solid currentColor;
      box-shadow:0 0 12px currentColor;
      transform:scale(1.05);
      animation:themeIconPulse 2s ease-in-out infinite;
    }
    @keyframes themeIconPulse{
      0%, 100%{box-shadow:0 0 12px currentColor;}
      50%{box-shadow:0 0 20px currentColor;}
    }
    .theme-chip[data-color="W"]{background-image:url('https://i.ibb.co/sJpHH9VZ/W.png');}
    .theme-chip[data-color="U"]{background-image:url('https://i.ibb.co/0bPLHLk/U.png');}
    .theme-chip[data-color="B"]{background-image:url('https://i.ibb.co/nM1ZZz3z/B.png');}
    .theme-chip[data-color="R"]{background-image:url('https://i.ibb.co/NnjxnmZv/R.png');}
    .theme-chip[data-color="G"]{background-image:url('https://i.ibb.co/tM5Mb1Q0/G.png');}

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      overflow:auto;
    }
    .slot-layout{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px;
    }
    .bottom-panels-container{
      display:flex;
      flex-direction:row;
      gap:12px;
      width:100%;
      max-width:100%;
      box-sizing:border-box;
    }
    .history-panel{
      flex:1 1 auto;
      max-width:calc(40% - 4px);
      background:radial-gradient(circle at top,var(--panel) 0,var(--bg) 50%,#000 100%);
      border-radius:16px;
      border:3px solid transparent;
      background-clip:padding-box;
      padding:10px;
      box-shadow:none;
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .history-panel::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .history-panel::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 8px var(--theme-glow));
    }
    .history-header{
      text-align:center;
      font-size:14px;
      font-weight:700;
      color:var(--gold);
      text-shadow:0 0 12px rgba(250,204,21,.6);
      margin-bottom:8px;
      text-transform:uppercase;
      letter-spacing:.15em;
    }
    .slot-panel,.leaderboard-panel{
      background:radial-gradient(circle at top,var(--panel) 0,var(--bg) 50%,#000 100%);
      border-radius:16px;
      border:3px solid transparent;
      background-clip:padding-box;
      padding:10px;
      box-shadow:none;
      position:relative;
      overflow:hidden;
    }
    .leaderboard-panel{
      flex:0 0 calc(60% - 8px);
      display:flex;
      flex-direction:column;
      order:-1;
      max-width:calc(60% - 8px);
    }
    .slot-panel::before,.leaderboard-panel::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .slot-panel::after,.leaderboard-panel::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 12px var(--theme-glow)) drop-shadow(0 0 6px var(--theme-glow));
    }
    .slot-header{
      display:none;
    }
    .slot-title{
      display:none;
    }
    #statusText{
      display:none;
    }
    .status-text{
      display:none;
    }
    @media(max-width:640px){
      #app{
        margin:0;
        border-radius:0;
        min-height:100vh;
      }
      header{
        padding:8px 12px;
        gap:6px;
      }
      .logo{
        width:90px;
        height:90px;
      }
      .logo img{
        width:75%;
        height:75%;
      }
      .title{
        font-size:18px;
      }
      .subtitle{
        font-size:10px;
      }
      .theme-toggle{
        gap:4px;
      }
      .theme-chip{
        width:26px;
        height:26px;
      }
      .header-top{
        flex-direction:column;
        align-items:center;
      }
      .header-spin-controls{
        width:100%;
        justify-content:center;
      }
      .spin-button{
        font-size:16px;
        padding:10px 32px;
      }
      .slot-layout{
        padding:6px;
        gap:6px;
      }
      .bottom-panels-container{
        flex-direction:column;
        gap:12px;
      }
      .history-panel{
        flex:1 1 auto;
        min-height:250px;
        max-width:100%;
        width:100%;
        order:1;
      }
      .leaderboard-panel{
        flex:0 0 auto;
        max-width:100%;
        width:100%;
        order:0;
      }
      .slot-panel,.leaderboard-panel{
        padding:8px;
      }
      .lever{
        display:none;
      }
      .lever-knob{
        display:none;
      }
      .lever.pull .lever-knob{display:none;}
      .reels-shell{
        padding:12px;
      }
      .reel-charts-wrapper{
        margin:8px 0;
      }
      .reel-charts{
        gap:8px;
      }
      .pie-chart{
        width:48px;
        height:48px;
        flex-shrink:0;
      }
      .pie-chart-inner{
        width:34px;
        height:34px;
        font-size:9px;
      }
      .reel-chart-label{
        font-size:9px;
      }
      .ticket-btn{
        width:20px;
        height:20px;
        font-size:12px;
      }
      .ticket-count{
        font-size:10px;
        min-width:24px;
      }
      .player-card{
        padding:10px;
        max-width:100%;
        overflow:hidden;
        word-wrap:break-word;
      }
      .winner-card,.help-card{
        max-width:calc(100vw - 20px);
        margin:0 10px;
        max-height:90vh;
        overflow-y:auto;
        overflow-x:hidden;
      }
      .help-body{
        max-height:60vh;
        overflow-y:auto;
        overflow-x:hidden;
      }
      .deck-table-wrapper{
        max-width:100%;
        overflow-x:auto;
      }
      .diag-result{
        word-wrap:break-word;
        overflow-wrap:break-word;
      }
    }
    .reels-shell{
      position:relative;
      padding:18px 18px 18px 18px;
    }
    .bulb-row{
      position:absolute;
      left:20px;
      right:20px;
      height:8px;
      display:flex;
      justify-content:space-between;
      pointer-events:none;
    }
    .bulb-row.top{top:4px;}
    .bulb-row.bottom{bottom:4px;}
    .bulb-col{
      position:absolute;
      top:18px;
      bottom:18px;
      width:8px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      pointer-events:none;
    }
    .bulb-col.left{left:4px;}
    .bulb-col.right{right:4px;}
    .bulb{
      width:8px;
      height:8px;
      border-radius:999px;
      background:#4b5563;
      box-shadow:0 0 4px rgba(0,0,0,.8);
      transition:background 0.3s, box-shadow 0.3s, transform 0.3s;
    }
    .bulb.active{
      box-shadow:0 0 10px currentColor;
    }
    .bulb.saving{
      animation:savePulse 0.6s ease-out;
    }
    .bulb.saving-wubrg{
      animation:savePulseWUBRG 0.6s ease-out;
    }
    .reels-box{
      position:relative;
      border-radius:16px;
      border:3px solid transparent;
      background:linear-gradient(180deg,#020617 0,#020617 40%,#000 100%);
      background-clip:padding-box;
      padding:10px 8px 14px;
      box-shadow:0 0 26px var(--theme-glow);
      overflow:hidden;
    }
    .reels-box::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 12px var(--theme-glow)) drop-shadow(0 0 6px var(--theme-glow));
    }
    .reel-labels{
      display:flex;
      justify-content:space-between;
      margin-bottom:4px;
      font-size:10px;
      color:var(--muted);
      letter-spacing:.10em;
    }
    .reels{display:flex;gap:6px;justify-content:space-between;}
    .reel{
      flex:1;
      background:radial-gradient(circle at top,#020617 0,#000 70%);
      border-radius:12px;
      border:1px solid rgba(148,116,72,.7);
      padding:16px 4px;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
      box-shadow:inset 0 0 18px rgba(15,23,42,.9),0 0 18px rgba(0,0,0,.9),0 0 24px var(--theme-glow);
    }
    body.theme-black .reel{
      background:radial-gradient(circle at top,rgba(192,132,252,0.15) 0,#1a0a2e 70%);
      box-shadow:inset 0 0 18px rgba(192,132,252,.12),0 0 18px rgba(192,132,252,.2),0 0 24px var(--theme-glow);
    }
    .reel-inner{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      transform:translateY(0);
      transition:transform .18s ease-out;
    }
    .reel-symbol{
      font-size:13px;
      font-weight:700;
      padding:4px 8px;
      border-radius:8px;
      width:100px;
      min-height:48px;
      text-align:center;
      box-shadow:0 0 10px rgba(15,23,42,.9);
      white-space:normal;
      overflow:hidden;
      line-height:1.2;
      display:flex;
      align-items:center;
      justify-content:center;
      word-wrap:break-word;
      hyphens:auto;
    }
    /* Dynamic name scaling based on length */
    .reel-symbol.name-short{font-size:16px;}
    .reel-symbol.name-medium{font-size:13px;}
    .reel-symbol.name-long{font-size:11px;}
    .reel-symbol.name-very-long{font-size:9px;letter-spacing:0;}
    .reel-symbol.name-extreme{font-size:8px;letter-spacing:0;line-height:1.1;}
    .reel-symbol.player{
      background:rgba(15,23,42,.95);
      border:1px solid rgba(248,250,252,.25);
      color:var(--accent);
      text-shadow:0 0 8px rgba(248,250,252,.7);
    }
    .reel-symbol.letter{
      background:rgba(15,23,42,.95);
      border:1px solid var(--gold);
      color:var(--gold);
      text-shadow:0 0 12px rgba(250,204,21,.9);
    }
    .reel-symbol.luna{
      background:rgba(15,23,42,.95);
      border:1px solid #f973fa;
      box-shadow:0 0 16px rgba(244,114,182,.9);
      color:#f9a8d4;
    }
    .reel-symbol.luna img{
      max-width:40px;
      max-height:40px;
      border-radius:999px;
      display:block;
    }
    .reel:nth-child(1) .reel-symbol.player{
      border-color:#fef9c3;
      box-shadow:0 0 12px rgba(250,250,209,.9);
      color:#fefce8;
    }
    .reel:nth-child(2) .reel-symbol.player{
      border-color:#38bdf8;
      box-shadow:0 0 12px rgba(56,189,248,.9);
      color:#e0f2fe;
    }
    .reel:nth-child(3) .reel-symbol.player{
      border-color:#c084fc;
      box-shadow:0 0 12px rgba(192,132,252,.9);
      color:#e9d5ff;
    }
    .reel:nth-child(4) .reel-symbol.player{
      border-color:#fb4b4b;
      box-shadow:0 0 12px rgba(248,113,113,.9);
      color:#fee2e2;
    }
    .reel:nth-child(5) .reel-symbol.player{
      border-color:#22c55e;
      box-shadow:0 0 12px rgba(34,197,94,.9);
      color:#dcfce7;
    }
    .reel.glow-win{
      box-shadow:0 0 28px rgba(250,204,21,.8),inset 0 0 20px rgba(250,250,250,.1);
      border-color:var(--gold);
    }
    .reel.glow-carlo{
      box-shadow:0 0 26px rgba(56,189,248,.9),inset 0 0 20px rgba(15,23,42,.95);
      border-color:var(--blue);
    }
    .reel.glow-luna{
      box-shadow:0 0 24px rgba(244,114,182,.95),inset 0 0 18px rgba(24,24,27,.9);
      border-color:#f973fa;
    }
    @keyframes reelCycle{
      0%, 100%{opacity:1;}
      50%{opacity:0.3;}
    }
    .reel.spinning .reel-symbol{
      animation:reelCycle 0.15s linear infinite;
    }
    .reel.spinning .reel-inner{
      display:flex;
      flex-direction:column;
    }
    .slot-controls{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      gap:10px;
      position:relative;
      z-index:1;
    }
    .status-text{font-size:11px;color:var(--muted);}
    /* Lever removed - spin button is sufficient */
    .lever{
      display:none;
    }
    .lever-knob{
      display:none;
    }
    .lever.pull .lever-knob{display:none;}
    .spin-button{
      border-radius:999px;
      padding:14px 42px;
      border:3px solid transparent;
      font-size:20px;
      font-weight:900;
      letter-spacing:.12em;
      cursor:pointer;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      text-shadow:none;
      box-shadow:none;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      overflow:hidden;
    }
    .spin-button::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .spin-button:disabled{
      opacity:.45;
      cursor:default;
      box-shadow:0 0 6px rgba(0,0,0,.4);
    }
    .spin-button:active:not(:disabled){
      transform:translateY(1px) scale(.99);
      box-shadow:0 0 16px var(--theme-glow),inset 0 0 6px rgba(0,0,0,.4);
    }
    .side-panel-header{
      display:flex;
      justify-content:center;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      align-items:center;
    }
    .side-panel-section-title{
      font-size:14px;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:var(--gold);
      text-shadow:0 0 8px rgba(250,204,21,.4);
      margin-bottom:10px;
      text-align:center;
    }
    .add-player-form{
      display:flex;
      gap:6px;
      margin-bottom:8px;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
    }
    .add-player-form input{
      flex:1;
      min-width:150px;
      max-width:100%;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      font-size:11px;
      padding:6px 8px;
    }
    .add-player-form button{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      font-size:12px;
      padding:6px 12px;
      color:#78350f;
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:.12em;
      cursor:pointer;
      text-shadow:none;
      box-shadow:none;
      position:relative;
      overflow:hidden;
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .add-player-form button::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:2px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .summary-cards{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px;
      margin-bottom:8px;
      font-size:11px;
    }
    .summary-card{
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
      padding:6px 8px;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .summary-label{
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.14em;
      font-size:10px;
    }
    .summary-value{font-weight:600;font-size:12px;}
    .leaderboard-wrapper{
      overflow:auto;
      border-radius:10px;
      border:2px solid rgba(148,116,72,.9);
      background:linear-gradient(145deg, rgba(30,30,30,0.95) 0%, rgba(0,0,0,0.9) 100%);
      margin-top:6px;
      box-shadow:0 0 16px rgba(0,0,0,0.5),inset 0 0 20px rgba(0,0,0,0.6);
      flex:1;
      min-height:0;
    }
    .leaderboard-wrapper::-webkit-scrollbar{
      display:block !important;
      width:8px;
      height:8px;
    }
    .leaderboard-wrapper::-webkit-scrollbar-track{
      background:rgba(0,0,0,0.3);
      border-radius:4px;
    }
    .leaderboard-wrapper::-webkit-scrollbar-thumb{
      background:var(--gradient-border);
      border-radius:4px;
      border:1px solid var(--border);
    }
    .leaderboard-wrapper::-webkit-scrollbar-thumb:hover{
      background:var(--theme-color);
      box-shadow:0 0 8px var(--theme-glow);
    }
    .leaderboard-table{
      width:100%;
      border-collapse:collapse;
      font-size:11px;
    }
    .leaderboard-table thead{
      background:rgba(0,0,0,0.95);
      position:sticky;
      top:0;
      z-index:1;
      box-shadow:0 2px 8px rgba(0,0,0,0.6);
    }
    .leaderboard-table th{
      font-weight:700;
      letter-spacing:0.05em;
      color:#d1bfa1;
      text-shadow:none;
    }
    .leaderboard-table th,
    .leaderboard-table td{
      border-bottom:1px solid rgba(148,116,72,.3);
      padding:4px 6px;
      text-align:center;
      vertical-align:top;
    }
    .leaderboard-table th{
      letter-spacing:.12em;
      font-size:10px;
      color:#d1bfa1;
    }
    .sortable-header{
      cursor:pointer;
      user-select:none;
      transition:color 0.2s ease;
    }
    .sortable-header:hover{
      color:var(--gold);
    }
    .sortable-header.active{
      color:var(--gold);
      font-weight:900;
    }
    .sort-indicator{
      font-size:8px;
      margin-left:2px;
      opacity:0.5;
    }
    .sortable-header.active .sort-indicator{
      opacity:1;
    }
    .player-row{cursor:pointer;}
    .player-row:hover{background:rgba(17,24,39,.9);}
    .time-cell{
      font-size:10px;
      color:#10b981;
      text-shadow:0 0 8px rgba(16,185,129,.6), 0 0 4px rgba(16,185,129,.8);
      white-space:nowrap;
      font-weight:600;
    }
    .sparks-count{font-size:10px;color:var(--muted);}
    .win-rate-good{color:var(--text);font-weight:600;}
    .win-rate-medium{color:var(--text);font-weight:600;}
    .win-rate-poor{color:#ef4444;font-weight:600;}
    .actions-cell{
      font-size:14px;
      text-align:center;
    }
    .actions-cell button{
      border:none;
      background:transparent;
      cursor:pointer;
      color:var(--muted);
    }
    .log{
      font-size:11px;
      overflow-y:auto;
      color:var(--muted);
      text-align:left;
      padding:8px;
      flex:1;
      min-height:0;
    }
    .log::-webkit-scrollbar{
      display:block !important;
      width:8px;
    }
    .log::-webkit-scrollbar-track{
      background:rgba(0,0,0,0.3);
      border-radius:4px;
    }
    .log::-webkit-scrollbar-thumb{
      background:var(--gradient-border);
      border-radius:4px;
      border:1px solid var(--border);
    }
    .log::-webkit-scrollbar-thumb:hover{
      background:var(--theme-color);
      box-shadow:0 0 8px var(--theme-glow);
    }
    .help-body::-webkit-scrollbar,
    .help-card::-webkit-scrollbar,
    .deck-table-wrapper::-webkit-scrollbar,
    .reel-charts-wrapper::-webkit-scrollbar{
      width:8px;
      height:8px;
    }
    .help-body::-webkit-scrollbar-track,
    .help-card::-webkit-scrollbar-track,
    .deck-table-wrapper::-webkit-scrollbar-track,
    .reel-charts-wrapper::-webkit-scrollbar-track{
      background:rgba(0,0,0,0.3);
      border-radius:4px;
    }
    .help-body::-webkit-scrollbar-thumb,
    .help-card::-webkit-scrollbar-thumb,
    .deck-table-wrapper::-webkit-scrollbar-thumb,
    .reel-charts-wrapper::-webkit-scrollbar-thumb{
      background:var(--gradient-border);
      border-radius:4px;
      border:1px solid var(--border);
    }
    .help-body::-webkit-scrollbar-thumb:hover,
    .help-card::-webkit-scrollbar-thumb:hover,
    .deck-table-wrapper::-webkit-scrollbar-thumb:hover,
    .reel-charts-wrapper::-webkit-scrollbar-thumb:hover{
      background:var(--theme-color);
      box-shadow:0 0 8px var(--theme-glow);
    }
    .log-timestamp{
      color:var(--gold);
      font-weight:600;
      text-shadow:0 0 6px rgba(250,204,21,.4);
    }
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.88);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:1000;
    }
    .overlay.show{display:flex;}
    .winner-card{
      width:calc(100% - 20px);
      max-width:420px;
      margin:0 auto;
      border-radius:18px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#1e293b 0,#020617 50%,#000 100%);
      background-clip:padding-box;
      padding:14px 16px 18px;
      box-shadow:0 0 40px rgba(250,204,21,.8);
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .winner-card::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:18px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .winner-card::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:18px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 16px var(--theme-glow)) drop-shadow(0 0 8px var(--theme-glow));
    }
    .winner-heading{
      font-size:20px;
      font-weight:900;
      letter-spacing:.12em;
      color:var(--gold);
      text-shadow:0 0 14px rgba(250,204,21,1);
      margin-bottom:6px;
    }
    .winner-name{
      font-size:18px;
      font-weight:800;
      margin-bottom:4px;
    }
    .winner-meta{
      font-size:12px;
      color:var(--muted);
      margin-bottom:10px;
    }
    .winner-actions{
      display:flex;
      justify-content:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .winner-actions button{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      font-size:11px;
      font-weight:700;
      padding:6px 10px;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:.12em;
      text-shadow:none;
      box-shadow:none;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      overflow:hidden;
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .winner-actions button::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .winner-actions button:hover{
      transform:scale(1.03);
      box-shadow:0 0 24px var(--theme-glow),inset 0 0 16px var(--theme-glow);
    }
    .winner-luna-sticker{
      position:absolute;
      right:-6px;
      bottom:-6px;
      width:96px;
      height:96px;
      opacity:.95;
    }
    .winner-luna-sticker img{
      width:100%;
      height:100%;
      object-fit:contain;
    }
    .finish-card{
      width:calc(100% - 20px);
      max-width:460px;
      max-height:calc(100vh - 40px);
      margin:0 auto;
      border-radius:18px;
      border:3px solid transparent;
      background:var(--panel);
      background-clip:padding-box;
      padding:14px 16px 18px;
      box-shadow:0 0 30px rgba(0,0,0,.9);
      font-size:12px;
      text-align:center;
      position:relative;
      overflow-y:auto;
      overflow-x:hidden;
    }
    .finish-card::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:18px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .finish-card::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:18px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 16px var(--theme-glow)) drop-shadow(0 0 8px var(--theme-glow));
    }
    .finish-title{
      font-size:14px;
      font-weight:700;
      margin-bottom:4px;
      position:relative;
      z-index:10;
      color:var(--gold);
      text-align:center;
    }
    .finish-sub{
      font-size:11px;
      color:var(--muted);
      margin-bottom:10px;
      position:relative;
      z-index:10;
      text-align:center;
    }
    .finish-field{
      margin-bottom:8px;
      position:relative;
      z-index:10;
    }
    .finish-label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:var(--muted);
      margin-bottom:4px;
      text-align:center;
    }
    .finish-input-row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      position:relative;
      z-index:10;
      justify-content:center;
      max-width:100%;
    }
    .adjust-btn{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      font-size:13px;
      font-weight:700;
      padding:8px 16px;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:.08em;
      text-shadow:none;
      box-shadow:none;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      z-index:10;
      overflow:hidden;
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .adjust-btn::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .adjust-btn:hover{
      transform:scale(1.03);
      box-shadow:0 0 24px var(--theme-glow),inset 0 0 16px var(--theme-glow);
    }
    .finish-input-row input[type="number"]{
      width:80px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      font-size:12px;
      padding:4px 8px;
    }
    .finish-input-row select{
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      font-size:12px;
      padding:4px 8px;
    }
    .color-chips{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      justify-content:center;
      position:relative;
      z-index:10;
    }
    .color-chip{
      border-radius:999px;
      border:1px solid var(--border);
      width:26px;
      height:26px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      background-color:transparent;
      background-repeat:no-repeat;
      background-position:center;
      background-size:contain;
      color:transparent;
      text-indent:-9999px;
      opacity:.7;
      position:relative;
      z-index:10;
    }
    .color-chip.active{
      opacity:1;
      border-color:var(--gold);
      box-shadow:0 0 10px rgba(250,204,21,.7);
    }
    .color-chip[data-color="W"]{background-image:url("https://i.ibb.co/sJpHH9VZ/W.png");}
    .color-chip[data-color="U"]{background-image:url("https://i.ibb.co/0bPLHLk/U.png");}
    .color-chip[data-color="B"]{background-image:url("https://i.ibb.co/nM1ZZz3z/B.png");}
    .color-chip[data-color="R"]{background-image:url("https://i.ibb.co/NnjxnmZv/R.png");}
    .color-chip[data-color="G"]{background-image:url("https://i.ibb.co/tM5Mb1Q0/G.png");}
    .color-chip[data-color="C"]{background-image:url("https://i.ibb.co/xt4Lpn0X/C.png");}
    .queue-choice{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      justify-content:center;
      position:relative;
      z-index:10;
    }
    .queue-chip{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      padding:4px 10px;
      font-size:11px;
      font-weight:700;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:.1em;
      text-shadow:none;
      box-shadow:none;
      opacity:.6;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      z-index:10;
      overflow:hidden;
    }
    .queue-chip::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .queue-chip.active{
      opacity:1;
      transform:scale(1.05);
      box-shadow:0 0 24px var(--theme-glow),inset 0 0 16px var(--theme-glow);
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .finish-actions{
      display:flex;
      justify-content:center;
      gap:6px;
      margin-top:8px;
      position:relative;
      z-index:10;
      flex-wrap:wrap;
      max-width:100%;
    }
    .finish-actions button{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      font-size:11px;
      font-weight:700;
      padding:6px 10px;
      text-transform:uppercase;
      letter-spacing:.12em;
      cursor:pointer;
      text-shadow:none;
      box-shadow:none;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      z-index:10;
      overflow:hidden;
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .finish-actions button::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .finish-actions button:hover{
      transform:scale(1.03);
      box-shadow:0 0 24px var(--theme-glow),inset 0 0 16px var(--theme-glow);
    }
    .finish-actions button.primary{
      font-weight:900;
    }
    .player-card{
      width:calc(100% - 20px);
      max-width:640px;
      max-height:90vh;
      margin:0 auto;
      border-radius:16px;
      border:3px solid transparent;
      background:var(--panel);
      background-clip:padding-box;
      padding:12px 14px;
      box-shadow:0 0 30px rgba(0,0,0,.9);
      overflow-y:auto;
      overflow-x:hidden;
      font-size:12px;
      position:relative;
      overflow-y:auto;
      overflow-x:hidden;
      display:flex;
      flex-direction:column;
    }
    .player-card::before{
      content:'';
      position:absolute;
      top:-3px;
      left:-3px;
      right:-3px;
      bottom:-3px;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .player-card::after{
      content:'';
      position:absolute;
      top:-3px;
      left:-3px;
      right:-3px;
      bottom:-3px;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 16px var(--theme-glow)) drop-shadow(0 0 8px var(--theme-glow));
    }
    .player-card-header{
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      margin-bottom:6px;
      gap:4px;
    }
    .player-card-name{
      font-weight:700;
      font-size:16px;
      text-align:center;
      color:#facc15;
      text-shadow:0 0 8px rgba(250, 204, 21, 0.6);
      letter-spacing:0.02em;
    }
    .player-card-status{
      font-size:11px;
      color:var(--muted);
    }
    .player-card-actions{
      display:flex;
      justify-content:center;
      gap:6px;
      margin:6px 0;
      flex-wrap:wrap;
    }
    .player-card-actions button{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      font-size:11px;
      font-weight:700;
      padding:4px 8px;
      text-transform:uppercase;
      letter-spacing:.1em;
      cursor:pointer;
      text-shadow:none;
      box-shadow:none;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      overflow:hidden;
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .player-card-actions button::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .player-card-actions button:hover{
      transform:scale(1.03);
      box-shadow:0 0 24px var(--theme-glow),inset 0 0 16px var(--theme-glow);
    }
    .reel-charts-wrapper{
      width:100%;
      overflow-x:auto;
      overflow-y:hidden;
      margin:12px 0;
      padding:4px 0;
      -webkit-overflow-scrolling:touch;
    }
    .reel-charts{
      display:flex;
      gap:12px;
      justify-content:center;
      flex-wrap:wrap;
      min-width:min-content;
    }
    .reel-chart{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
    }
    .reel-chart-label{
      font-size:10px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.1em;
    }
    .pie-chart{
      width:60px;
      height:60px;
      border-radius:50%;
      position:relative;
      border:5px solid transparent;
      background:conic-gradient(var(--theme-color) 0% var(--percentage), rgba(0,0,0,.3) var(--percentage) 100%);
      background-clip:padding-box;
      box-shadow:0 0 8px var(--theme-glow),0 0 16px var(--theme-glow);
      display:flex;
      align-items:center;
      justify-content:center;
      filter:brightness(1.2);
      overflow:hidden;
      transition:all .15s ease-out;
    }
    .pie-chart::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:50%;
      padding:5px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .pie-chart-inner{
      width:44px;
      height:44px;
      border-radius:50%;
      background:var(--bg);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      font-weight:bold;
      color:var(--gold);
    }
    .reel-ticket-controls{
      display:flex;
      align-items:center;
      gap:6px;
      margin-top:4px;
    }
    .ticket-btn{
      width:24px;
      height:24px;
      border-radius:4px;
      border:2px solid transparent;
      background:rgba(0,0,0,0.3);
      background-clip:padding-box;
      color:var(--gold);
      font-size:14px;
      font-weight:800;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:all .15s ease-out;
      box-shadow:0 0 6px var(--theme-glow);
      position:relative;
      overflow:hidden;
    }
    .ticket-btn::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:4px;
      padding:2px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .ticket-btn:hover{
      background:var(--theme-color);
      color:var(--bg);
      box-shadow:0 0 12px var(--theme-glow);
      transform:scale(1.1);
    }
    .ticket-count{
      font-size:12px;
      font-weight:600;
      color:var(--text);
      opacity:0.7;
      min-width:32px;
      text-align:center;
    }
    .deck-table-wrapper{
      width:100%;
      overflow-x:auto;
      margin-top:6px;
      -webkit-overflow-scrolling:touch;
    }
    .deck-table{
      width:100%;
      border-collapse:collapse;
      font-size:11px;
      min-width:300px;
    }
    .deck-table th,.deck-table td{
      padding:3px 4px;
      text-align:center;
      white-space:nowrap;
    }
    .deck-table tr{
      border-bottom:1px solid var(--border);
    }
    .deck-table th{
      text-transform:uppercase;
      letter-spacing:.1em;
      font-size:10px;
      color:var(--muted);
      font-weight:900;
    }
    .footer-bar{
      position:sticky;
      bottom:0;
      left:0;
      right:0;
      padding:12px 14px;
      background:rgba(10,9,8,.95);
      border-top:1px solid var(--border);
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:11px;
      color:var(--muted);
    }
    .footer-buttons{
      display:flex;
      gap:16px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .footer-buttons button{
      border-radius:999px;
      border:3px solid transparent;
      background:radial-gradient(circle at top,#fef3c7 0,#fde68a 50%,#fcd34d 100%);
      background-clip:padding-box;
      color:#78350f;
      font-size:10px;
      font-weight:900;
      padding:7px 12px;
      text-transform:uppercase;
      letter-spacing:.1em;
      cursor:pointer;
      text-shadow:none;
      box-shadow:none;
      transition:transform .1s ease-out,box-shadow .1s ease-out,opacity .1s ease-out;
      position:relative;
      overflow:hidden;
    }
    /* Gold mode styling removed - all buttons now use pale gold */
    .footer-buttons button::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:999px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:1;
    }
    .footer-buttons button:hover{
      transform:scale(1.03);
      box-shadow:0 0 24px var(--theme-glow),inset 0 0 16px var(--theme-glow);
    }
    .help-card{
      width:calc(100% - 20px);
      max-width:520px;
      border-radius:16px;
      border:3px solid transparent;
      background:var(--panel);
      background-clip:padding-box;
      padding:12px 14px;
      box-shadow:0 0 30px rgba(0,0,0,.9);
      font-size:12px;
      position:relative;
      overflow-x:hidden;
      overflow-y:auto;
      max-height:90vh;
      margin:0 10px;
    }
    .help-card::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .help-card::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 16px var(--theme-glow)) drop-shadow(0 0 8px var(--theme-glow));
    }
    .help-title{
      font-size:14px;
      font-weight:700;
      margin-bottom:4px;
      color:var(--gold);
      text-align:center;
    }
    .help-section-title{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:var(--muted);
      margin-top:12px;
      margin-bottom:6px;
      text-align:center;
    }
    .help-grid-container{
      width:calc(100% - 20px);
      max-width:700px;
      border-radius:16px;
      border:3px solid transparent;
      background:var(--panel);
      background-clip:padding-box;
      padding:20px;
      box-shadow:0 0 30px rgba(0,0,0,.9);
      position:relative;
      margin:0 10px;
    }
    .help-grid-container::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-shadow);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:blackLayerShift 6s ease-in-out infinite;
      z-index:99;
      opacity:0.4;
    }
    .help-grid-container::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:16px;
      padding:3px;
      background:var(--gradient-border);
      background-size:var(--gradient-border-size) var(--gradient-border-size);
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      animation:gradientShift 4s ease infinite;
      z-index:100;
      filter:drop-shadow(0 0 16px var(--theme-glow)) drop-shadow(0 0 8px var(--theme-glow));
    }
    .help-grid-title{
      font-size:16px;
      font-weight:700;
      margin-bottom:16px;
      color:var(--gold);
      text-align:center;
      position:relative;
      z-index:101;
    }
    .help-grid{
      display:grid;
      grid-template-columns:repeat(3, 1fr);
      gap:12px;
      margin-bottom:16px;
      position:relative;
      z-index:101;
    }
    @media (max-width: 650px){
      .help-grid{
        grid-template-columns:repeat(2, 1fr);
      }
    }
    @media (max-width: 450px){
      .help-grid{
        grid-template-columns:1fr;
      }
    }
    .help-box{
      background:rgba(0,0,0,0.4);
      border:1px solid rgba(148,116,72,.3);
      border-radius:8px;
      padding:12px;
      text-align:center;
      box-shadow:0 2px 8px rgba(0,0,0,.3), inset 0 1px 0 rgba(255,255,255,.05);
      transition:transform 0.2s ease, box-shadow 0.2s ease;
    }
    .help-box:hover{
      transform:translateY(-2px);
      box-shadow:0 4px 12px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.08);
    }
    .help-box-title{
      font-size:13px;
      font-weight:700;
      color:var(--gold);
      margin-bottom:6px;
      text-transform:uppercase;
      letter-spacing:0.05em;
    }
    .help-box-text{
      font-size:11px;
      color:var(--muted);
      line-height:1.5;
    }
    .spark-progression{
      display:flex;
      flex-direction:row;
      align-items:center;
      justify-content:center;
      gap:6px;
      margin:12px 0;
      flex-wrap:wrap;
    }
    .spark-bulbs-row{
      display:flex;
      gap:6px;
      justify-content:center;
    }
    .spark-bulb{
      width:24px;
      height:24px;
      border-radius:50%;
      background:rgba(0,0,0,0.5);
      border:2px solid rgba(148,116,72,.5);
      transition:all .3s ease;
      position:relative;
    }
    .spark-bulb.lit{
      background:var(--theme-color);
      border-color:var(--theme-color);
      box-shadow:0 0 8px var(--theme-glow),0 0 16px var(--theme-glow),inset 0 0 6px var(--theme-glow);
      animation:sparkPulse 1.5s ease-in-out infinite;
    }
    @keyframes sparkPulse{
      0%, 100%{
        opacity:1;
        transform:scale(1);
        box-shadow:0 0 8px var(--theme-glow),0 0 16px var(--theme-glow),inset 0 0 6px var(--theme-glow);
      }
      50%{
        opacity:0.85;
        transform:scale(1.08);
        box-shadow:0 0 12px var(--theme-glow),0 0 24px var(--theme-glow),inset 0 0 10px var(--theme-glow);
      }
    }
    .spark-overflow-bulb{
      width:60px;
      height:20px;
      border-radius:10px;
      background:rgba(0,0,0,0.5);
      border:2px solid rgba(148,116,72,.5);
      display:flex;
      align-items:center;
      justify-content:center;
      transition:all .3s ease;
      position:relative;
    }
    .spark-overflow-bulb.ready.lit{
      background:#fcd34d;
      border-color:#fcd34d;
      box-shadow:0 0 12px rgba(252,211,77,0.6),0 0 24px rgba(252,211,77,0.4);
    }
    .spark-overflow-bulb.ignition.lit{
      background:linear-gradient(90deg, #fefce8, #38bdf8, #4b5563, #fb4b4b, #22c55e, #fefce8);
      background-size:200% 100%;
      border:2px solid transparent;
      background-clip:padding-box;
      box-shadow:0 0 12px rgba(252,211,77,0.6),0 0 24px rgba(56,189,248,0.4),0 0 12px rgba(239,68,68,0.4);
      animation:ignitionPulse 1s ease-in-out infinite, rainbowShift 3s linear infinite;
      position:relative;
    }
    .spark-overflow-bulb.ignition.lit::before{
      content:'';
      position:absolute;
      inset:-2px;
      border-radius:10px;
      background:linear-gradient(90deg, #fefce8, #38bdf8, #4b5563, #fb4b4b, #22c55e, #fefce8);
      background-size:200% 100%;
      z-index:1;
      animation:rainbowShift 3s linear infinite;
    }
    @keyframes rainbowShift{
      0%{background-position:0% 50%;}
      100%{background-position:200% 50%;}
    }
    @keyframes ignitionPulse{
      0%, 100%{box-shadow:0 0 12px rgba(252,211,77,0.6),0 0 24px rgba(56,189,248,0.4),0 0 12px rgba(239,68,68,0.4);}
      50%{box-shadow:0 0 20px rgba(252,211,77,0.8),0 0 40px rgba(56,189,248,0.6),0 0 20px rgba(239,68,68,0.6);}
    }
    .spark-overflow-label{
      font-size:8px;
      font-weight:800;
      letter-spacing:.08em;
      color:rgba(255,255,255,0.4);
      text-transform:uppercase;
    }
    .spark-overflow-bulb.lit .spark-overflow-label{
      color:#000;
    }
    .help-body{
      font-size:11px;
      color:var(--muted);
      text-align:center;
    }
    .help-body p{
      margin:4px 0;
      line-height:1.4;
    }
    .diag-result{
      margin-top:6px;
      font-size:11px;
      text-align:center;
    }
    .diag-result span.pass{color:var(--ok);}
    .diag-result span.warn{color:var(--danger);}
  </style>
</head>
<body class="theme-white">
<div id="app">
  <header>
    <div class="header-top">
      <div class="logo">
        <img src="https://i.ibb.co/bRQkqqG5/Chat-GPT-Image-Nov-17-2025-08-45-44-AM-removebg-preview.png" alt="CoAST"/>
      </div>
      <div class="title-block">
        <div class="title">Viewer Roulette</div>
        <div class="subtitle">Pick A Theme</div>
        <div class="theme-toggle">
          <div class="theme-chip" data-color="W">W</div>
          <div class="theme-chip" data-color="U">U</div>
          <div class="theme-chip" data-color="B">B</div>
          <div class="theme-chip" data-color="R">R</div>
          <div class="theme-chip" data-color="G">G</div>
        </div>
      </div>
      <div class="header-spin-controls">
        <button class="spin-button" id="spinBtn">SPIN</button>
      </div>
    </div>
  </header>

  <main>
    <div class="slot-layout">
      <!-- SLOT SIDE -->
      <section class="slot-panel">
        <div class="slot-header">
          <div class="slot-title">Five-Reel Viewer Slot</div>
          <div id="statusText">Add players, then spin.</div>
        </div>
        <div class="reels-shell">
          <div class="bulb-row top" id="bulbRowTop"></div>
          <div class="bulb-row bottom" id="bulbRowBottom"></div>
          <div class="bulb-col left" id="bulbColLeft"></div>
          <div class="bulb-col right" id="bulbColRight"></div>
          <div class="reels-box">
            <div class="reels" id="reels"></div>
          </div>
          <div class="lever" id="lever">
            <div class="lever-knob"></div>
          </div>
        </div>
        <div class="slot-controls">
          <div class="status-text" id="smallStatus">Ready.</div>
        </div>
      </section>
      <!-- BOTTOM PANELS (LEADERBOARD + HISTORY) -->
      <div class="bottom-panels-container">
        <!-- LEADERBOARD PANEL (LEFT - 60%) -->
        <section class="leaderboard-panel">
          <div class="side-panel-header">
            <div class="side-panel-section-title">Leaderboard Odds</div>
          </div>
          <div id="playerCountHeader" style="font-size:10px;color:var(--muted);text-align:center;margin-bottom:8px;"></div>
          <form class="add-player-form" id="addPlayerForm" autocomplete="off">
            <input type="text" id="playerNameInput" name="player-name-input" placeholder="Add viewer (name / handle)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            <button type="submit">Add</button>
          </form>
          <div class="leaderboard-wrapper">
            <table class="leaderboard-table">
              <thead>
                <tr>
                  <th class="sortable-header" data-sort="time">Time <span class="sort-indicator"></span></th>
                  <th>Player</th>
                  <th class="sortable-header" data-sort="overall">Overall% <span class="sort-indicator"></span></th>
                  <th class="sortable-header" data-sort="total">Total <span class="sort-indicator"></span></th>
                  <th class="sortable-header" data-sort="slotWins">Slot W <span class="sort-indicator"></span></th>
                  <th class="sortable-header" data-sort="winRate">W/L% <span class="sort-indicator"></span></th>
                  <th class="sortable-header" data-sort="sparks">Sparks <span class="sort-indicator"></span></th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="leaderboardBody"></tbody>
            </table>
          </div>
        </section>
        <!-- HISTORY LOG PANEL (RIGHT - 40%) -->
        <section class="history-panel">
          <div class="history-header" id="historyHeader" style="cursor:pointer;user-select:none;">
            History Log <span id="historyExpandIcon" style="font-size:10px;margin-left:4px;"></span>
          </div>
          <div class="log" id="log"></div>
        </section>
      </div>
    </div>
  </main>
  <div class="footer-bar">
    <div class="footer-buttons">
      <button id="helpBtn">Help</button>
      <button id="diagBtn">Hypergeometric Diagnostic</button>
      <button id="exportBtn">Export Session</button>
      <button id="importBtn">Import Session</button>
      <button id="resetEventBtn">Factory Reset Session</button>
    </div>
  </div>
  <input type="file" id="importFileInput" accept=".json" style="display:none;"/>
  <!-- WINNER OVERLAY -->
  <div class="overlay" id="winnerOverlay">
    <div class="winner-card">
      <div class="winner-heading" id="winnerHeading">WINNER</div>
      <div class="winner-name" id="winnerName"></div>
      <div class="winner-meta" id="winnerMeta"></div>
      <div class="winner-actions">
        <button id="winnerExportPlayBtn"> Export and Play</button>
        <button id="winnerSkipBtn">Skip and Remove</button>
      </div>
      <div class="winner-luna-sticker" id="winnerLunaSticker" style="display:none;">
        <img src="https://i.ibb.co/23vVSmXN/LunaGG.png" alt="Luna">
      </div>
    </div>
  </div>
  <!-- FINISH RUN OVERLAY -->
  <div class="overlay" id="finishOverlay">
    <div class="finish-card">
      <div class="finish-title">Report Deck Run Results</div>
      <div class="finish-sub">
        Enter how this deck performed before returning to the slot.
      </div>
      <div class="finish-field">
        <div class="finish-label">Match Format</div>
        <div class="queue-choice" id="matchTypeChoice">
          <div class="queue-chip" data-match-type="BO1">Best of 1</div>
          <div class="queue-chip active" data-match-type="BO3">Best of 3</div>
          <div class="queue-chip" data-match-type="BO5">Best of 5</div>
        </div>
      </div>
      <div class="finish-field">
        <div class="finish-label">How many matches were played?</div>
        <div class="finish-input-row" style="justify-content:center;gap:8px;">
          <button type="button" class="adjust-btn" id="removeMatchBtn"></button>
          <input type="number" id="matchesPlayed" min="0" value="0" style="width:60px;text-align:center;padding:4px;border-radius:4px;border:1px solid var(--border);background:var(--bg);color:var(--text);" readonly />
          <button type="button" class="adjust-btn" id="addMatchBtn">+</button>
        </div>
      </div>
      <div class="finish-field">
        <div class="finish-label">Wins and Losses</div>
        <div style="display:flex;gap:12px;justify-content:center;align-items:center;margin-top:8px;">
          <div style="text-align:center;">
            <div style="font-size:10px;color:var(--muted);margin-bottom:4px;">Wins</div>
            <div class="finish-input-row" style="justify-content:center;">
              <button type="button" class="adjust-btn" id="removeWinBtn"></button>
              <input type="number" id="runWins" min="0" value="0" style="width:50px;text-align:center;padding:4px;border-radius:4px;border:1px solid var(--border);background:var(--bg);color:var(--text);" readonly />
              <button type="button" class="adjust-btn" id="addWinBtn">+</button>
            </div>
          </div>
          <div style="text-align:center;">
            <div style="font-size:10px;color:var(--muted);margin-bottom:4px;">Losses</div>
            <div class="finish-input-row" style="justify-content:center;">
              <button type="button" class="adjust-btn" id="removeLossBtn"></button>
              <input type="number" id="runLosses" min="0" value="0" style="width:50px;text-align:center;padding:4px;border-radius:4px;border:1px solid var(--border);background:var(--bg);color:var(--text);" readonly />
              <button type="button" class="adjust-btn" id="addLossBtn">+</button>
            </div>
          </div>
        </div>
      </div>
      <div class="finish-field" id="opponentColorsContainer">
        <!-- Dynamically populated based on match type and matches played -->
      </div>
      <div class="finish-actions">
        <button type="button" id="finishCancelBtn">Cancel</button>
        <button type="button" class="primary" id="finishSaveBtn" style="pointer-events:auto!important;z-index:9999;position:relative;">Save Results</button>
      </div>
    </div>
  </div>
  <!-- RE-ADD TO QUEUE OVERLAY -->
  <div class="overlay" id="requeueOverlay">
    <div class="finish-card" style="max-width:400px;">
      <div class="finish-title">Re-add to Queue?</div>
      <div class="finish-sub">
        Would you like <span id="requeuePlayerName"></span> to be re-added to the queue?
      </div>
      <div class="finish-actions" style="margin-top:16px;">
        <button type="button" id="requeueYesBtn" class="primary">Yes</button>
        <button type="button" id="requeueNoBtn">No</button>
      </div>
    </div>
  </div>
  <!-- BONUS REWARD OVERLAY -->
  <div class="overlay" id="bonusRewardOverlay">
    <div class="finish-card" style="max-width:400px;">
      <div class="finish-title">Bonus Reward</div>
      <div class="finish-sub">
        <span id="bonusPlayerName"></span> hit <span id="bonusHitCount"></span> symbols!<br>
        How would you like to use your bonus tickets?
      </div>
      <div class="queue-choice" id="bonusChoice" style="margin-top:16px;">
        <div class="queue-chip active" data-choice="tickets">Bonus Tickets</div>
        <div class="queue-chip" data-choice="games">Extra Games</div>
      </div>
      <div class="finish-actions" style="margin-top:16px;">
        <button type="button" id="bonusConfirmBtn" class="primary">Confirm</button>
      </div>
    </div>
  </div>
  <!-- PLAYER DETAIL OVERLAY -->
  <div class="overlay" id="playerOverlay">
    <div class="player-card">
      <div class="player-card-header">
        <div class="player-card-name" id="playerCardName"></div>
        <div class="player-card-status" id="playerCardStatus"></div>
      </div>
      <div class="help-section-title">Reel Probabilities</div>
      <div class="reel-charts-wrapper">
        <div class="reel-charts" id="reelCharts"></div>
      </div>
      <div class="help-section-title">Spark Progression (<span id="playerSparkCount">0</span>/12)</div>
      <div class="spark-progression">
        <div class="spark-bulbs-row">
          <div class="spark-bulb" data-spark="1"></div>
          <div class="spark-bulb" data-spark="2"></div>
          <div class="spark-bulb" data-spark="3"></div>
          <div class="spark-bulb" data-spark="4"></div>
          <div class="spark-bulb" data-spark="5"></div>
        </div>
        <div class="spark-overflow-bulb ready" data-spark="6">
          <div class="spark-overflow-label">READY</div>
        </div>
        <div class="spark-bulbs-row">
          <div class="spark-bulb" data-spark="7"></div>
          <div class="spark-bulb" data-spark="8"></div>
          <div class="spark-bulb" data-spark="9"></div>
          <div class="spark-bulb" data-spark="10"></div>
          <div class="spark-bulb" data-spark="11"></div>
        </div>
        <div class="spark-overflow-bulb ignition" data-spark="12">
          <div class="spark-overflow-label">IGNITED</div>
        </div>
      </div>
      <div class="help-section-title deck-section-header" id="deckSectionHeader" style="cursor:pointer;user-select:none;">
        Decks (by color identity) <span id="deckExpandIcon" style="font-size:10px;"></span>
      </div>
      <div class="deck-table-wrapper" id="deckTableWrapper">
        <table class="deck-table">
          <thead>
            <tr>
              <th class="sortable-header" data-deck-sort="colors">Colors <span class="sort-indicator"></span></th>
              <th class="sortable-header" data-deck-sort="matches">Matches <span class="sort-indicator"></span></th>
              <th class="sortable-header" data-deck-sort="wl">W/L <span class="sort-indicator"></span></th>
              <th class="sortable-header" data-deck-sort="winRate">Win% <span class="sort-indicator"></span></th>
              <th style="cursor:default;">Matchups</th>
              <th class="sortable-header" data-deck-sort="last">Last <span class="sort-indicator"></span></th>
              <th style="cursor:default;text-align:center;">Actions</th>
            </tr>
          </thead>
          <tbody id="deckTableBody"></tbody>
        </table>
      </div>
      <div class="player-card-actions" style="margin-top:12px;">
        <button id="exportPlayerDeckBtn" style="display:none;"> Export Deck</button>
        <button id="toggleAfkBtn">Toggle AFK</button>
        <button id="removePlayerBtn">Remove Player</button>
        <button id="closePlayerCardBtn">Close</button>
      </div>
    </div>
  </div>
  <!-- DECK EDITOR OVERLAY -->
  <div class="overlay" id="deckEditorOverlay">
    <div class="finish-card">
      <div class="finish-title">Edit Deck</div>
      <div class="finish-sub">Correct deck stats and color identity</div>

      <div class="finish-field">
        <div class="finish-label">Deck Colors</div>
        <div class="color-chips" id="deckEditorColorChips">
          <div class="color-chip" data-color="W">W</div>
          <div class="color-chip" data-color="U">U</div>
          <div class="color-chip" data-color="B">B</div>
          <div class="color-chip" data-color="R">R</div>
          <div class="color-chip" data-color="G">G</div>
          <div class="color-chip" data-color="C">C</div>
        </div>
      </div>

      <div class="finish-field">
        <div class="finish-label">Wins</div>
        <div class="finish-controls">
          <button id="deckEditorWinsDown" class="finish-btn-inc"></button>
          <input type="number" id="deckEditorWins" min="0" value="0" class="finish-input"/>
          <button id="deckEditorWinsUp" class="finish-btn-inc">+</button>
        </div>
      </div>

      <div class="finish-field">
        <div class="finish-label">Losses</div>
        <div class="finish-controls">
          <button id="deckEditorLossesDown" class="finish-btn-inc"></button>
          <input type="number" id="deckEditorLosses" min="0" value="0" class="finish-input"/>
          <button id="deckEditorLossesUp" class="finish-btn-inc">+</button>
        </div>
      </div>

      <div class="finish-field">
        <div class="finish-label">Match Type</div>
        <select id="deckEditorMatchType" class="finish-select">
          <option value="BO1">Best of 1</option>
          <option value="BO3" selected>Best of 3</option>
          <option value="BO5">Best of 5</option>
        </select>
      </div>

      <div class="finish-actions">
        <button id="deckEditorSaveBtn" class="finish-save-btn">Save Changes</button>
        <button id="deckEditorDeleteBtn" class="finish-cancel-btn" style="background:var(--danger,#dc2626);">Delete Deck</button>
        <button id="closeDeckEditorBtn" class="finish-cancel-btn">Cancel</button>
      </div>
    </div>
  </div>
  <!-- DECK IMPORT OVERLAY -->
  <div class="overlay" id="deckImportOverlay">
    <div class="finish-card" style="max-width:500px;">
      <div class="finish-title">Import Deck for <span id="deckImportPlayerName"></span></div>
      <div class="finish-sub">
        Select deck color identity. Copy your MTG Arena deck list, then click Import.
      </div>
      <div class="finish-field">
        <div class="finish-label">Deck Color Identity</div>
        <div class="color-chips" id="deckImportColorChips">
          <div class="color-chip" data-color="W">W</div>
          <div class="color-chip" data-color="U">U</div>
          <div class="color-chip" data-color="B">B</div>
          <div class="color-chip" data-color="R">R</div>
          <div class="color-chip" data-color="G">G</div>
          <div class="color-chip" data-color="C">C</div>
        </div>
      </div>
      <div class="finish-actions">
        <button id="deckImportSaveBtn" class="finish-save-btn"> Import Deck from Clipboard</button>
        <button id="deckImportSkipBtn" class="finish-cancel-btn">Skip (No Deck)</button>
      </div>
    </div>
  </div>
  <!-- HELP OVERLAY -->
  <div class="overlay" id="helpOverlay">
    <div class="help-grid-container">
      <div class="help-grid-title">How It Works</div>
      <div class="help-grid">
        <div class="help-box">
          <div class="help-box-title">How To Win</div>
          <div class="help-box-text">Get 3+ matches on the reels. Winner plays until they lose.</div>
        </div>
        <div class="help-box">
          <div class="help-box-title">Tickets</div>
          <div class="help-box-text">Your odds per reel. Start at 1, double when you don't appear. Higher tickets = better chances.</div>
        </div>
        <div class="help-box">
          <div class="help-box-title">Sparks</div>
          <div class="help-box-text">Earned when tickets exceed 500. Get 12 sparks and you're IGNITED  guaranteed win!</div>
        </div>
        <div class="help-box">
          <div class="help-box-title">Luna</div>
          <div class="help-box-text">Wild card that helps complete wins. Max 1 per spin.</div>
        </div>
        <div class="help-box">
          <div class="help-box-title">CoAST</div>
          <div class="help-box-text">Jackpot! All 5 reels show C-o-A-S-T letters. Streamer plays their deck.</div>
        </div>
        <div class="help-box">
          <div class="help-box-title">Meta-Tracking</div>
          <div class="help-box-text">Track deck performance and matchup data. View detailed analytics in Player Diagnostics.</div>
        </div>
      </div>
      <div class="finish-actions">
        <button id="closeHelpBtn">Close</button>
      </div>
    </div>
  </div>
  <!-- DIAGNOSTIC OVERLAY -->
  <div class="overlay" id="diagOverlay">
    <div class="help-card">
      <div class="help-title">Hypergeometric Diagnostic</div>
      <div class="help-body">
        <p>Simulates 300 spins with the current player list & weights (no changes to the live event). Checks for balanced win rates, CoAST/Luna frequency, 4oak/5oak occurrences, and Ignition rates.</p>
        <div class="finish-actions">
          <button id="runDiagNowBtn">Run Simulation</button>
          <button id="closeDiagBtn">Close</button>
        </div>
        <div class="diag-result" id="diagResult"></div>
      </div>
    </div>
  </div>

  <!-- SESSION RESUME MODAL -->
  <div class="overlay" id="sessionResumeOverlay">
    <div class="finish-card">
      <div class="finish-title">Previous Session Found</div>
      <div class="finish-sub">
        A previous session was detected.<br>
        Would you like to continue where you left off?
      </div>
      <div class="finish-actions" style="margin-top:20px;">
        <button id="sessionResumeBtn" style="background:var(--ok);color:#000;">Resume Previous Session</button>
        <button id="sessionNewBtn" style="background:var(--panel);color:var(--text);">Start New Session</button>
      </div>
    </div>
  </div>

  <!-- FACTORY RESET MODAL -->
  <div class="overlay" id="factoryResetOverlay">
    <div class="finish-card">
      <div class="finish-title" style="color:var(--danger);"> WARNING: Factory Reset</div>
      <div class="finish-sub">
        This will permanently delete:<br>
         All players and decks<br>
         Match history<br>
         Session data<br>
         Statistics<br><br>
        <strong>This CANNOT be undone.</strong>
      </div>
      <div class="finish-field">
        <div class="finish-label">Type "RESET" to confirm</div>
        <input type="text" id="factoryResetInput" placeholder="RESET"
               style="width:100%;padding:10px;font-size:14px;text-align:center;background:var(--panel);border:2px solid var(--border);border-radius:8px;color:var(--text);text-transform:uppercase;" />
      </div>
      <div class="finish-actions" style="margin-top:20px;">
        <button id="factoryResetCancelBtn" style="background:var(--panel);color:var(--text);">Cancel</button>
        <button id="factoryResetConfirmBtn" style="background:var(--danger);color:#fff;opacity:0.3;cursor:not-allowed;" disabled>Factory Reset</button>
      </div>
    </div>
  </div>
</div>
<script>
(function(){
  "use strict";
  const MAX_EVENTS = 7;
  const MAX_PLAYERS = 75;
  const TICKET_CAP = 500;
  const MAX_SPARKS = 12;
  const LUNA_BASE_ODDS = 1/30; // Base odds for 1-5 players
  const CARLO_LETTER_ODDS = 1/75; // Base odds for 1-3 players

  // Letter image URLs for CoAST
  const LETTER_IMAGES = {
    'C': 'https://i.ibb.co/7xmFbNBL/ei-1764001300945-removebg-preview-ezgif-com-crop.png',
    'o': 'https://i.ibb.co/MyMbbYfP/ei-1764001300945-removebg-preview1-ezgif-com-crop.png',
    'A': 'https://i.ibb.co/HT1kdLY5/ei-1764001300945-removebg-preview3-ezgif-com-crop.png',
    'S': 'https://i.ibb.co/mrGHHC5Y/ei-1764001300945-removebg-preview5-ezgif-com-crop.png',
    'T': 'https://i.ibb.co/Mk08w1jh/ei-1764002393914-removebg-preview-ezgif-com-crop.png'
  };

  // DYNAMIC PROBABILITY SCALING - Adjusts game balance based on active player count

  // Dynamic CARLO letter odds: Lower odds = MORE player symbols = HIGHER win rates
  function getCarloLetterOdds(activePlayerCount){
    if(activePlayerCount <= 3) return 1/75;     // Original odds (1.33% per reel)
    if(activePlayerCount <= 5) return 1/85;     // Slightly lower (1.18% per reel)
    if(activePlayerCount <= 10) return 1/95;    // Lower for medium groups (1.05% per reel)
    if(activePlayerCount <= 20) return 1/110;   // Much lower for large groups (0.91% per reel)
    if(activePlayerCount <= 35) return 1/130;   // Very low for very large groups (0.77% per reel)
    return 1/150;                                // Minimal for maximum capacity (0.67% per reel)
  }

  // Dynamic Luna spawn odds: Higher frequency at high player counts to compensate for dilution
  function getLunaBaseOdds(activePlayerCount){
    if(activePlayerCount <= 5) return 1/30;    // Original odds (~3.33% per spin)
    if(activePlayerCount <= 10) return 1/25;   // 20% more frequent (~4% per spin)
    if(activePlayerCount <= 20) return 1/20;   // 50% more frequent (~5% per spin)
    if(activePlayerCount <= 35) return 1/15;   // 100% more frequent (~6.67% per spin)
    return 1/12;                                // 150% more frequent for max capacity (~8.33% per spin)
  }

  // Dead spin guardrail: Guarantee win after too many dead spins
  function getMaxDeadStreakAllowed(activePlayerCount){
    if(activePlayerCount <= 3) return 15;      // Solo/duo - moderate variance
    if(activePlayerCount <= 7) return 12;      // Small groups - balanced
    if(activePlayerCount <= 15) return 9;      // Medium groups - tighter flow
    if(activePlayerCount <= 25) return 7;      // Medium-large - quick engagement
    if(activePlayerCount <= 40) return 6;      // Large groups - very tight
    return 6;                                   // Maximum capacity - maintain pace
  }

  const reelsEl = document.getElementById('reels');
  const spinBtn = document.getElementById('spinBtn');
  const leverEl = document.getElementById('lever');
  const smallStatus = document.getElementById('smallStatus');
  const statusText = document.getElementById('statusText');
  const spinCountEl = document.getElementById('spinCount');
  const deadStreakEl = document.getElementById('deadStreak');
  const playerCountEl = document.getElementById('playerCount');
  const leaderboardBody = document.getElementById('leaderboardBody');
  const logEl = document.getElementById('log');
  const historyHeader = document.getElementById('historyHeader');
  const historyExpandIcon = document.getElementById('historyExpandIcon');
  const eventChipsEl = document.getElementById('eventChips');
  const bulbRowTop = document.getElementById('bulbRowTop');
  const bulbRowBottom = document.getElementById('bulbRowBottom');
  const bulbColLeft = document.getElementById('bulbColLeft');
  const bulbColRight = document.getElementById('bulbColRight');
  const addPlayerForm = document.getElementById('addPlayerForm');
  const playerNameInput = document.getElementById('playerNameInput');
  const winnerOverlay = document.getElementById('winnerOverlay');
  const winnerHeading = document.getElementById('winnerHeading');
  const winnerNameEl = document.getElementById('winnerName');
  const winnerMetaEl = document.getElementById('winnerMeta');
  const winnerExportPlayBtn = document.getElementById('winnerExportPlayBtn');
  const winnerSkipBtn = document.getElementById('winnerSkipBtn');
  const winnerLunaSticker = document.getElementById('winnerLunaSticker');
  const finishOverlay = document.getElementById('finishOverlay');
  const runWinsInput = document.getElementById('runWins');
  const runLossesInput = document.getElementById('runLosses');
  const matchesPlayedInput = document.getElementById('matchesPlayed');
  const addMatchBtn = document.getElementById('addMatchBtn');
  const removeMatchBtn = document.getElementById('removeMatchBtn');
  const addWinBtn = document.getElementById('addWinBtn');
  const removeWinBtn = document.getElementById('removeWinBtn');
  const addLossBtn = document.getElementById('addLossBtn');
  const removeLossBtn = document.getElementById('removeLossBtn');
  const matchTypeChoice = document.getElementById('matchTypeChoice');
  const opponentColorsContainer = document.getElementById('opponentColorsContainer');
  const finishCancelBtn = document.getElementById('finishCancelBtn');
  const finishSaveBtn = document.getElementById('finishSaveBtn');
  const requeueOverlay = document.getElementById('requeueOverlay');
  const requeuePlayerName = document.getElementById('requeuePlayerName');
  const requeueYesBtn = document.getElementById('requeueYesBtn');
  const requeueNoBtn = document.getElementById('requeueNoBtn');
  const bonusRewardOverlay = document.getElementById('bonusRewardOverlay');
  const bonusPlayerName = document.getElementById('bonusPlayerName');
  const bonusHitCount = document.getElementById('bonusHitCount');
  const bonusChoice = document.getElementById('bonusChoice');
  const bonusConfirmBtn = document.getElementById('bonusConfirmBtn');
  const playerOverlay = document.getElementById('playerOverlay');
  const playerCardName = document.getElementById('playerCardName');
  const playerCardStatus = document.getElementById('playerCardStatus');
  const toggleAfkBtn = document.getElementById('toggleAfkBtn');
  const removePlayerBtn = document.getElementById('removePlayerBtn');
  const closePlayerCardBtn = document.getElementById('closePlayerCardBtn');
  const exportPlayerDeckBtn = document.getElementById('exportPlayerDeckBtn');
  const deckTableBody = document.getElementById('deckTableBody');
  const deckTableWrapper = document.getElementById('deckTableWrapper');
  const deckSectionHeader = document.getElementById('deckSectionHeader');
  const deckExpandIcon = document.getElementById('deckExpandIcon');
  const deckEditorOverlay = document.getElementById('deckEditorOverlay');
  const deckEditorColorChips = document.getElementById('deckEditorColorChips');
  const deckEditorWins = document.getElementById('deckEditorWins');
  const deckEditorLosses = document.getElementById('deckEditorLosses');
  const deckEditorWinsUp = document.getElementById('deckEditorWinsUp');
  const deckEditorWinsDown = document.getElementById('deckEditorWinsDown');
  const deckEditorLossesUp = document.getElementById('deckEditorLossesUp');
  const deckEditorLossesDown = document.getElementById('deckEditorLossesDown');
  const deckEditorMatchType = document.getElementById('deckEditorMatchType');
  const deckEditorSaveBtn = document.getElementById('deckEditorSaveBtn');
  const deckEditorDeleteBtn = document.getElementById('deckEditorDeleteBtn');
  const closeDeckEditorBtn = document.getElementById('closeDeckEditorBtn');
  const deckImportOverlay = document.getElementById('deckImportOverlay');
  const deckImportPlayerName = document.getElementById('deckImportPlayerName');
  const deckImportColorChips = document.getElementById('deckImportColorChips');
  const deckImportSaveBtn = document.getElementById('deckImportSaveBtn');
  const deckImportSkipBtn = document.getElementById('deckImportSkipBtn');
  const helpOverlay = document.getElementById('helpOverlay');
  const diagOverlay = document.getElementById('diagOverlay');
  const helpBtn = document.getElementById('helpBtn');
  const diagBtn = document.getElementById('diagBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const importFileInput = document.getElementById('importFileInput');
  const resetEventBtn = document.getElementById('resetEventBtn');
  const closeHelpBtn = document.getElementById('closeHelpBtn');
  const closeDiagBtn = document.getElementById('closeDiagBtn');
  const runDiagNowBtn = document.getElementById('runDiagNowBtn');
  const diagResult = document.getElementById('diagResult');
  const sessionResumeOverlay = document.getElementById('sessionResumeOverlay');
  const sessionResumeBtn = document.getElementById('sessionResumeBtn');
  const sessionNewBtn = document.getElementById('sessionNewBtn');
  const factoryResetOverlay = document.getElementById('factoryResetOverlay');
  const factoryResetInput = document.getElementById('factoryResetInput');
  const factoryResetCancelBtn = document.getElementById('factoryResetCancelBtn');
  const factoryResetConfirmBtn = document.getElementById('factoryResetConfirmBtn');
  const themeChips = document.querySelectorAll('.theme-chip');
  const currentResults = document.getElementById('currentResults');

  const state = {currentEventIndex: 0,events: []};
  let selectedColors = new Set(); // Multi-select theme colors (empty = white glow default)
  let selectedColorSet = new Set();
  let deckEditorColorSet = new Set(); // Track deck editor color selections
  let currentEditingPlayer = null; // Track which player's deck is being edited
  let currentEditingDeck = null; // Track which deck is being edited
  let currentSortColumn = 'total'; // Default sort by total tickets (probability)
  let currentSortDirection = 'desc'; // desc = highest first, asc = lowest first
  let currentDeckSortColumn = 'winRate'; // Default deck sort by win rate
  let currentDeckSortDirection = 'desc'; // desc = highest first
  let pendingWinner = null;
  let currentWinnerMeta = null;
  let bulbsTimer = null;
  let timeTimer = null;
  let currentPlayerCardId = null;
  let pendingImportPlayer = null; // Track player waiting for deck import
  let deckImportColorSet = new Set(); // Track selected colors for deck import
  let hasUnreportedGame = false; // Track if there's an unreported game
  let unreportedGamePlayer = null; // Track which player has unreported game

  // Ignition Queue System - FIFO with scaling cooldowns
  let ignitedQueue = []; // Array of player IDs ready for ignition
  let lastIgnitionSpin = -1; // Spin count when last ignition occurred

  // Ignition cooldown configuration (spins between ignitions)
  function getIgnitionCooldown(activePlayerCount){
    if(activePlayerCount <= 3) return 0; // No cooldown with few players
    if(activePlayerCount <= 5) return 1; // 1 spin cooldown
    if(activePlayerCount <= 10) return 2; // 2 spin cooldown
    if(activePlayerCount <= 20) return 3; // 3 spin cooldown
    return 4; // 4 spin cooldown for large queues
  }

  // Handle Match Count buttons
  addMatchBtn.addEventListener('click',()=>{
    const current = parseInt(matchesPlayedInput.value,10)||0;
    matchesPlayedInput.value = current + 1;
    regenerateOpponentColorSelectors();
  });

  removeMatchBtn.addEventListener('click',()=>{
    const current = parseInt(matchesPlayedInput.value,10)||0;
    if(current > 0){
      matchesPlayedInput.value = current - 1;
      regenerateOpponentColorSelectors();
    }
  });

  // Handle Win buttons
  addWinBtn.addEventListener('click',()=>{
    const current = parseInt(runWinsInput.value,10)||0;
    runWinsInput.value = current + 1;
    regenerateOpponentColorSelectors();
  });

  removeWinBtn.addEventListener('click',()=>{
    const current = parseInt(runWinsInput.value,10)||0;
    if(current > 0){
      runWinsInput.value = current - 1;
      regenerateOpponentColorSelectors();
    }
  });

  // Handle Loss buttons
  addLossBtn.addEventListener('click',()=>{
    const current = parseInt(runLossesInput.value,10)||0;
    runLossesInput.value = current + 1;
    regenerateOpponentColorSelectors();
  });

  removeLossBtn.addEventListener('click',()=>{
    const current = parseInt(runLossesInput.value,10)||0;
    if(current > 0){
      runLossesInput.value = current - 1;
      regenerateOpponentColorSelectors();
    }
  });

  matchTypeChoice.addEventListener('click',e=>{
    const chip = e.target.closest('.queue-chip');
    if(!chip) return;
    Array.from(matchTypeChoice.children).forEach(ch=>{
      ch.classList.toggle('active', ch===chip);
    });
    regenerateOpponentColorSelectors();
  });

  function currentEvent(){
    if(!state.events[state.currentEventIndex]){
      state.events[state.currentEventIndex] = {
        players: [],
        spinCount: 0,
        deadSpinStreak: 0,
        currentRun: null,
        carloHits: 0,
        lunaHits: 0,
        lastSpinWasWinner: false
      };
    }
    return state.events[state.currentEventIndex];
  }

  function log(msg){
    const time = new Date().toLocaleTimeString();
    const div = document.createElement('div');
    div.innerHTML = `<span class="log-timestamp">[${time}]</span> ${msg}`;
    logEl.prepend(div);
  }
  function saveAll(){
    try{
      localStorage.setItem('carlo_slot_events', JSON.stringify(state));
    }catch(e){
      console.warn("Save failed", e);
    }
  }
  function loadAll(){
    try{
      const raw = localStorage.getItem('carlo_slot_events');
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(!parsed || typeof parsed !== 'object') return;
      if(parsed.events) state.events = parsed.events;
      if(parsed.currentEventIndex) state.currentEventIndex = parsed.currentEventIndex;
      for(const evt of state.events){
        if(!evt) continue;
        evt.players = evt.players || [];
        evt.spinCount = evt.spinCount || 0;
        evt.deadSpinStreak = evt.deadSpinStreak || 0;
        evt.currentRun = evt.currentRun || null;
        evt.carloHits = evt.carloHits || 0;
        evt.lunaHits = evt.lunaHits || 0;
        evt.lastSpinWasWinner = evt.lastSpinWasWinner || false;
        for(const p of evt.players){
          p.tickets = p.tickets || [1,1,1,1,1];
          p.sparks = p.sparks || 0;
          if(p.pityPoints && p.pityPoints > 0){
            p.sparks = Math.min(MAX_SPARKS, p.sparks + 1);
          }
          p.pityPoints = 0;
          p.slotWins = p.slotWins || 0;
          p.slotGames = p.slotGames || 0;
          p.overallWins = p.overallWins || 0;
          p.overallLosses = p.overallLosses || 0;
          p.createdAt = p.createdAt || Date.now();
          p.status = p.status || 'active';
          p.decks = p.decks || [];
        }
      }
    }catch(e){
      console.warn("Load failed", e);
    }
  }

  function clampPlayer(p){
    for(let i=0;i<5;i++){
      if(p.tickets[i] < 1) p.tickets[i] = 1;  // Never allow 0 tickets
      if(p.tickets[i] > TICKET_CAP) p.tickets[i] = TICKET_CAP;
    }
    if(p.sparks < 0) p.sparks = 0;
    if(p.sparks > MAX_SPARKS) p.sparks = MAX_SPARKS;
  }

  function totalTickets(p){
    return p.tickets.reduce((a,b)=>a+b,0);
  }
  function overallWinRate(p){
    const total = p.overallWins + p.overallLosses;
    if(total === 0) return 0;
    return (p.overallWins / total) * 100;
  }
  function calculateOverallOdds(player, evt){
    // Calculate average percentage across all 5 reels
    if(!evt) return 0;
    const activePlayers = evt.players.filter(p => p.status === 'active');
    if(activePlayers.length === 0) return 0;

    let totalPercentage = 0;
    for(let i = 0; i < 5; i++){
      const totalForReel = activePlayers.reduce((sum, p) => sum + p.tickets[i], 0);
      const playerTickets = player.tickets[i];
      const percentage = totalForReel > 0 ? ((playerTickets / totalForReel) * 100) : 0;
      totalPercentage += percentage;
    }
    return totalPercentage / 5; // Average of 5 reels
  }
  function getColorThemeName(colors){
    if(!colors) return '';
    const sorted = colors.split('').sort().join(''); // Normalize order
    const themeMap = {
      // Colorless
      'C': 'Colorless',
      // Mono-color
      'W': 'White',
      'U': 'Blue',
      'B': 'Black',
      'R': 'Red',
      'G': 'Green',
      // 2-color (Guilds)
      'UW': 'Azorius',
      'BU': 'Dimir',
      'BR': 'Rakdos',
      'GR': 'Gruul',
      'GW': 'Selesnya',
      'BW': 'Orzhov',
      'RU': 'Izzet',
      'BG': 'Golgari',
      'RW': 'Boros',
      'GU': 'Simic',
      // 3-color (Shards)
      'BUW': 'Esper',
      'BRU': 'Grixis',
      'BGR': 'Jund',
      'GRW': 'Naya',
      'GUW': 'Bant',
      // 3-color (Wedges)
      'BGW': 'Abzan',
      'RUW': 'Jeskai',
      'BGU': 'Sultai',
      'BRW': 'Mardu',
      'GRU': 'Temur',
      // 4-color (Nephilim)
      'BGRU': 'Glint-Eye',
      'BGRW': 'Dune-Brood',
      'GRUW': 'Ink-Treader',
      'BGUW': 'Witch-Maw',
      'BRUW': 'Yore-Tiller',
      // 5-color
      'BGRUW': 'Prismatic'
    };
    return themeMap[sorted] || colors;
  }
  function formatTimeInQueue(ms){
    const s = Math.floor(ms/1000);
    const m = Math.floor(s/60);
    const h = Math.floor(m/60);
    if(h>0) return `${h}h ${m%60}m`;
    if(m>0) return `${m}m ${s%60}s`;
    return `${s}s`;
  }

  function renderEvents(){
  }

  function initBulbs(){
    function createRow(rowEl, count){
      rowEl.innerHTML = '';
      for(let i=0;i<count;i++){
        const b = document.createElement('div');
        b.className = 'bulb';
        rowEl.appendChild(b);
      }
    }
    function createCol(colEl, count){
      colEl.innerHTML = '';
      for(let i=0;i<count;i++){
        const b = document.createElement('div');
        b.className = 'bulb';
        colEl.appendChild(b);
      }
    }
    createRow(bulbRowTop, 10);
    createRow(bulbRowBottom, 10);
    createCol(bulbColLeft, 4);
    createCol(bulbColRight, 4);
  }

  const BULB_COLORS = ['#fefce8','#38bdf8','#020617','#ef4444','#22c55e'];
  const BULB_LUNA_COLORS = ['#fdf2ff','#fb7185','#ec4899','#f973fa'];
  function startBulbsAnimation(isLunaWin){
    stopBulbsAnimation();
    const top = bulbRowTop.querySelectorAll('.bulb');
    const bottom = bulbRowBottom.querySelectorAll('.bulb');
    const left = bulbColLeft.querySelectorAll('.bulb');
    const right = bulbColRight.querySelectorAll('.bulb');

    // Arrange bulbs in clockwise rotation order: top-left to top-right, then right-top to right-bottom, then bottom-right to bottom-left, then left-bottom to left-top
    const topArray = Array.from(top);
    const rightArray = Array.from(right);
    const bottomArray = Array.from(bottom).reverse();
    const leftArray = Array.from(left).reverse();
    const all = [...topArray, ...rightArray, ...bottomArray, ...leftArray];

    let t = 0;
    const trailLength = 8; // Number of bulbs to light up in the trail
    bulbsTimer = setInterval(()=>{
      // For Luna wins: use pink colors. For others: randomly cycle all non-pink colors
      const availableColors = isLunaWin ? BULB_LUNA_COLORS : BULB_COLORS;

      // Turn off all bulbs first
      all.forEach(b => {
        b.classList.remove('active');
        b.style.background = '#4b5563';
        b.style.color = '#4b5563';
      });

      // Light up trailing bulbs with random color cycling
      for(let i = 0; i < trailLength; i++){
        const idx = (t - i + all.length) % all.length;
        const bulb = all[idx];
        // Random color from available palette
        const c = availableColors[Math.floor(Math.random() * availableColors.length)];
        const opacity = 1 - (i / trailLength) * 0.7; // Fade trail
        bulb.style.color = c;
        bulb.style.background = c;
        bulb.style.opacity = opacity;
        bulb.classList.add('active');
      }
      t = (t + 1) % all.length;
    },80);
  }
  function stopBulbsAnimation(){
    if(bulbsTimer) clearInterval(bulbsTimer);
    bulbsTimer = null;
    const all = document.querySelectorAll('.bulb');
    all.forEach(b=>{
      b.classList.remove('active');
      b.style.background='#4b5563';
    });
  }

  function setupReelsPlaceholder(){
    reelsEl.innerHTML = '';
    const letters = ['C','o','A','S','T'];
    for(let i=0;i<5;i++){
      const reel = document.createElement('div');
      reel.className = 'reel';
      const inner = document.createElement('div');
      inner.className = 'reel-inner';
      const sym = document.createElement('div');
      sym.className = 'reel-symbol letter';
      const img = document.createElement('img');
      img.src = LETTER_IMAGES[letters[i]];
      img.alt = letters[i];
      sym.appendChild(img);
      inner.appendChild(sym);
      reel.appendChild(inner);
      reelsEl.appendChild(reel);
    }
  }

  let reelCycleIntervals = [];

  function spinAnimationStart(){
    const evt = currentEvent();
    const reelEls = reelsEl.querySelectorAll('.reel');
    const letters = ['C','o','A','S','T'];
    const allPlayers = evt.players.filter(p => p.status === 'active');

    // Clear any existing intervals
    reelCycleIntervals.forEach(iv => clearInterval(iv));
    reelCycleIntervals = [];

    reelEls.forEach((r, idx)=>{
      r.classList.add('spinning');
      r.classList.remove('glow-win','glow-carlo','glow-luna');

      // Create single symbol that will cycle content
      const inner = r.querySelector('.reel-inner');
      if(inner){
        inner.innerHTML = '';
        const div = document.createElement('div');
        div.className = 'reel-symbol player';
        div.textContent = letters[idx];
        inner.appendChild(div);

        // Cycle the symbol's content rapidly
        const interval = setInterval(() => {
          const rand = Math.random();
          if(rand < 0.4 && allPlayers.length > 0){
            // Random player
            const p = allPlayers[Math.floor(Math.random() * allPlayers.length)];
            div.className = 'reel-symbol player';
            div.textContent = p.name;
            div.innerHTML = p.name;
          }else if(rand < 0.5){
            // Luna (rare)
            div.className = 'reel-symbol luna';
            div.innerHTML = `<img src="https://i.ibb.co/8g6ZQM5C/IMG-2604.png" alt="Luna">`;
          }else{
            // Letter
            div.className = 'reel-symbol letter';
            div.innerHTML = `<img src="${LETTER_IMAGES[letters[idx]]}" alt="${letters[idx]}">`;
          }
        }, 100); // Change every 100ms

        reelCycleIntervals.push(interval);
      }
    });
    // Don't start bulbs here - will be started in performSpin for proper timing
  }
  function spinAnimationStop(){
    const reelEls = reelsEl.querySelectorAll('.reel');
    reelEls.forEach(r=>r.classList.remove('spinning'));
    // Clear all cycling intervals
    reelCycleIntervals.forEach(iv => clearInterval(iv));
    reelCycleIntervals = [];
    stopBulbsAnimation();
  }

  // Cascade reel stops over 660ms with random timing
  // Last reel stops ~1500-1700ms (longer, more dramatic spin)
  function spinAnimationStopCascade(callback){
    const reelEls = reelsEl.querySelectorAll('.reel');
    const TAPER_DURATION = 1000; // 1 second cascade
    const BASE_START = 600; // First reel starts stopping at ~600ms
    const RANDOM_VARIANCE = 60; // 60ms random variation per reel

    // Generate random delays for each reel
    const delays = [];
    for(let i = 0; i < 5; i++){
      const baseDelay = BASE_START + (i * (TAPER_DURATION / 4)); // Spread over 660ms
      const randomOffset = (Math.random() - 0.5) * 2 * RANDOM_VARIANCE; // -40 to +40ms
      delays.push(Math.max(0, baseDelay + randomOffset));
    }

    // Stop each reel at its calculated time
    let stoppedCount = 0;
    delays.forEach((delay, index) => {
      setTimeout(() => {
        reelEls[index].classList.remove('spinning');
        // Clear the interval for this specific reel
        if(reelCycleIntervals[index]){
          clearInterval(reelCycleIntervals[index]);
        }
        stoppedCount++;
        if(stoppedCount === 5 && callback){
          // All reels stopped, invoke callback
          reelCycleIntervals = [];
          callback();
        }
      }, delay);
    });
  }

  // Parse MTG Arena deck list and detect color identity
  function parseDeckList(deckText){
    const lines = deckText.split('\n');
    const cards = [];
    const colorSet = new Set();

    // Color detection from mana symbols in card names
    const colorPatterns = {
      'W': /\{W\}|Plains|white/i,
      'U': /\{U\}|Island|blue/i,
      'B': /\{B\}|Swamp|black/i,
      'R': /\{R\}|Mountain|red/i,
      'G': /\{G\}|Forest|green/i
    };

    // Basic land detection
    const basicLands = {
      'Plains': 'W',
      'Island': 'U',
      'Swamp': 'B',
      'Mountain': 'R',
      'Forest': 'G'
    };

    // Dual/Tri lands and other color indicators
    const landColorMap = {
      // Shock lands
      'Temple Garden': 'GW', 'Hallowed Fountain': 'WU', 'Watery Grave': 'UB',
      'Blood Crypt': 'BR', 'Stomping Ground': 'RG', 'Godless Shrine': 'WB',
      'Steam Vents': 'UR', 'Overgrown Tomb': 'BG', 'Sacred Foundry': 'RW',
      'Breeding Pool': 'UG',
      // Fast lands
      'Seachrome Coast': 'WU', 'Darkslick Shores': 'UB', 'Blackcleave Cliffs': 'BR',
      'Copperline Gorge': 'RG', 'Razorverge Thicket': 'GW', 'Concealed Courtyard': 'WB',
      'Spirebluff Canal': 'UR', 'Blooming Marsh': 'BG', 'Inspiring Vantage': 'RW',
      'Botanical Sanctum': 'UG',
      // Pain lands
      'Adarkar Wastes': 'WU', 'Underground River': 'UB', 'Sulfurous Springs': 'BR',
      'Karplusan Forest': 'RG', 'Brushland': 'GW', 'Caves of Koilos': 'WB',
      'Shivan Reef': 'UR', 'Llanowar Wastes': 'BG', 'Battlefield Forge': 'RW',
      'Yavimaya Coast': 'UG',
      // Creature lands
      'Celestial Colonnade': 'WU', 'Creeping Tar Pit': 'UB', 'Lavaclaw Reaches': 'BR',
      'Raging Ravine': 'RG', 'Stirring Wildwood': 'GW', 'Shambling Vent': 'WB',
      'Wandering Fumarole': 'UR', 'Hissing Quagmire': 'BG', 'Needle Spires': 'RW',
      'Lumbering Falls': 'UG',
      // Survey lands
      'Sunlit Marsh': 'WB', 'Shadowy Backstreet': 'UB', 'Raucous Theater': 'BR',
      'Commercial District': 'RW', 'Lush Portico': 'GW', 'Elegant Parlor': 'WU',
      'Undercity Sewers': 'BG', 'Thundering Falls': 'UR', 'Hedge Maze': 'GW',
      'Underground Mortuary': 'BG',
      // Other common duals
      'Fabled Passage': '', 'Evolving Wilds': '', 'Terramorphic Expanse': '',
      'Wastewood Verge': 'BG', 'Starting Town': ''
    };

    let inSideboard = false;
    for(const line of lines){
      const trimmed = line.trim();

      // Skip empty lines
      if(!trimmed) continue;

      // Check for Sideboard section and skip it
      if(trimmed.toLowerCase() === 'sideboard'){
        inSideboard = true;
        continue;
      }
      if(trimmed.toLowerCase() === 'deck'){
        inSideboard = false;
        continue;
      }

      // Skip sideboard cards
      if(inSideboard) continue;

      // Match format: "4 Lightning Bolt (DOM) 111" or "4x Lightning Bolt"
      const match = trimmed.match(/^(\d+)x?\s+(.+?)(?:\s+\([\w\d]+\)\s*\d*)?$/i);
      if(match){
        const count = parseInt(match[1], 10);
        const cardName = match[2].trim();
        cards.push({count, name: cardName});

        // Check for basic lands
        for(const [land, color] of Object.entries(basicLands)){
          if(cardName.includes(land)){
            colorSet.add(color);
          }
        }

        // Check dual/tri lands
        for(const [landName, colors] of Object.entries(landColorMap)){
          if(cardName.includes(landName)){
            for(const c of colors){
              colorSet.add(c);
            }
          }
        }

        // Check for color indicators in card name
        for(const [color, pattern] of Object.entries(colorPatterns)){
          if(pattern.test(cardName)){
            colorSet.add(color);
          }
        }
      }
    }

    return {
      cards,
      colors: Array.from(colorSet).sort((a,b) => {
        const order = ['W','U','B','R','G'];
        return order.indexOf(a) - order.indexOf(b);
      }).join(''),
      rawText: deckText
    };
  }

  // Helper: Check if player has valid deck list
  function hasValidDeckList(player){
    return player && player.deckList && player.deckList.trim();
  }

  // Helper: Export deck to clipboard with visual feedback
  function exportDeckToClipboard(player, buttonElement){
    if(!hasValidDeckList(player)){
      alert('No deck list found for this player.');
      return;
    }
    navigator.clipboard.writeText(player.deckList).then(()=>{
      log(`Deck exported to clipboard for ${player.name}`);
      const originalText = buttonElement.textContent;
      buttonElement.textContent = ' Copied!';
      setTimeout(()=>{
        buttonElement.textContent = originalText;
      }, 2000);
    }).catch(err=>{
      console.error('Failed to copy:', err);
      alert('Failed to copy deck to clipboard. Please try again.');
    });
  }

  // Show deck import dialog for a player
  function showDeckImportDialog(player){
    console.log(' showDeckImportDialog called for:', player.name);
    pendingImportPlayer = player;
    deckImportPlayerName.textContent = player.name;

    // Reset color selection
    deckImportColorSet.clear();
    Array.from(deckImportColorChips.children).forEach(ch => ch.classList.remove('active'));

    deckImportOverlay.classList.add('show');
    console.log(' Overlay shown');
  }

  function addPlayer(name, skipImport = false){
    const evt = currentEvent();
    if(evt.players.length >= MAX_PLAYERS){
      smallStatus.textContent = "Player cap reached for this session.";
      return;
    }
    name = name.trim();
    if(!name) return;

    // Note: Duplicate check happens AFTER color selection in import dialog
    // This allows same player with different color identities (e.g., Foozi:UB vs Foozi:WB)

    const p = {
      id: Date.now() + Math.random().toString(16).slice(2),
      name,  // Will be updated to "Name:Colors" format after import
      baseName: name,  // Store original name without colors
      colorIdentity: null,  // Will be set during import
      tickets:[1,1,1,1,1],
      sparks:0,
      slotWins:0,
      slotGames:0,
      overallWins:0,
      overallLosses:0,
      createdAt:Date.now(),
      status:'active',
      decks:[]
    };
    evt.players.push(p);
    log(`Added player ${name} to the session.`);
    renderLeaderboard();
    const lbWrap = document.querySelector('.leaderboard-wrapper');
    if(lbWrap) lbWrap.scrollTop = lbWrap.scrollHeight;
    saveAll();

    // Show deck import dialog unless skipped
    console.log(' addPlayer completed for:', name, 'skipImport:', skipImport);
    if(!skipImport){
      console.log(' Scheduling showDeckImportDialog in 100ms...');
      setTimeout(() => showDeckImportDialog(p), 100);
    } else {
      console.log(' Skipping deck import dialog (skipImport=true)');
    }
  }

  function randomWeightedPlayer(evt, reelIndex){
    const candidates = evt.players.filter(p=>p.status==='active');
    if(candidates.length === 0) return null;
    let total = 0;
    for(const p of candidates){
      total += p.tickets[reelIndex];
    }
    if(total <= 0) return null;
    let r = Math.random() * total;
    for(const p of candidates){
      r -= p.tickets[reelIndex];
      if(r <= 0) return p;
    }
    return candidates[candidates.length-1];
  }

  function applyOverflowToSparks(player, overflow){
    if(overflow <= 0) return;
    // Every 500 overflow = 1 spark
    const tokens = Math.floor(overflow / TICKET_CAP);
    if(tokens > 0){
      player.sparks = Math.min(MAX_SPARKS, (player.sparks || 0) + tokens);
    }
  }

  function doubleTicketsAllReels(player){
    const oldTotal = totalTickets(player);
    const oldSparks = player.sparks || 0;
    for(let i=0;i<5;i++){
      const raw = player.tickets[i] * 2;
      if(raw <= TICKET_CAP){
        // No overflow, just set to doubled amount
        player.tickets[i] = raw;
      } else {
        // Overflow: raw exceeds 500 cap
        const overflow = raw - TICKET_CAP;

        // Calculate sparks from overflow (every 500 overflow = 1 spark)
        const sparksFromOverflow = Math.floor(overflow / TICKET_CAP);
        if(sparksFromOverflow > 0){
          player.sparks = Math.min(MAX_SPARKS, (player.sparks || 0) + sparksFromOverflow);
        }

        // Calculate remaining tickets after overflow
        let newTickets = overflow % TICKET_CAP;
        if(newTickets === 0){
          // If exactly divisible, keep minimum viable tickets
          newTickets = 1;
        }
        player.tickets[i] = newTickets;
      }
    }
    clampPlayer(player);
    const newTotal = totalTickets(player);
    const newSparks = player.sparks;
    if(newSparks > oldSparks){
      log(`${player.name}: tickets ${oldTotal}${newTotal}, sparks ${oldSparks}${newSparks} (+${newSparks-oldSparks})`);
    }
  }

  function halveTicketsAllReels(player){
    // HALVE+1 logic: halve tickets (round up), then add +1, minimum 1
    for(let i=0;i<5;i++){
      const halved = Math.ceil(player.tickets[i] / 2);
      player.tickets[i] = Math.max(1, halved + 1);
    }
    clampPlayer(player);
  }

  function handleDeadSpinTickets(evt, symbols, reelPlayers){
    const drawnIds = new Set(reelPlayers.map(r=>r.playerId));
    const activePlayerCount = evt.players.filter(p => p.status === 'active').length;

    for(const p of evt.players){
      if(p.status !== 'active') continue;
      if(drawnIds.has(p.id)){
        // Player appeared: lose -1 on that specific reel(s)
        for(const rp of reelPlayers){
          if(rp.playerId === p.id){
            const i = rp.index;
            p.tickets[i] = Math.max(1, p.tickets[i]-1);
          }
        }
      }else{
        // Player didn't appear: apply scaled ticket growth based on player count
        // Larger groups need faster ticket escalation for natural wins before guardrail
        let multiplier;
        if (activePlayerCount <= 7) {
          multiplier = 0.60; // Moderate penalty for small groups
        } else if (activePlayerCount <= 15) {
          multiplier = 0.80; // Mild penalty for medium groups
        } else if (activePlayerCount <= 25) {
          multiplier = 1.12; // Healthy growth for medium-large (12% per dead spin)
        } else if (activePlayerCount <= 40) {
          multiplier = 1.15; // Faster growth for large groups (15% per dead spin)
        } else {
          multiplier = 1.18; // Fastest growth for very large groups (18% per dead spin)
        }

        for(let i=0; i<5; i++){
          p.tickets[i] = Math.max(1, Math.ceil(p.tickets[i] * multiplier));
        }
      }
      clampPlayer(p);
    }
  }

  function handleWinTickets(evt, winner, symbols, reelPlayers){
    const winnerId = winner.id;
    const drawnIds = new Set(reelPlayers.map(r=>r.playerId));
    for(const p of evt.players){
      if(p.status !== 'active') continue;
      if(p.id === winnerId){
        continue;
      }
      if(drawnIds.has(p.id)){
        for(const rp of reelPlayers){
          if(rp.playerId === p.id){
            const i = rp.index;
            p.tickets[i] = Math.max(1, p.tickets[i]-1);
          }
        }
      }else{
        doubleTicketsAllReels(p);
      }
      clampPlayer(p);
    }
  }

  function findIgnitedPlayer(evt){
    const candidates = evt.players.filter(p => p.status === 'active' && p.sparks >= MAX_SPARKS);
    if(candidates.length === 0) return null;
    candidates.sort((a,b) => {
      if(a.createdAt !== b.createdAt) return a.createdAt - b.createdAt;
      if(b.sparks !== a.sparks) return b.sparks - a.sparks;
      const totDiff = totalTickets(b) - totalTickets(a);
      if(totDiff !== 0) return totDiff;
      return a.name.localeCompare(b.name);
    });
    return candidates[0];
  }

  // Update ignition queue with all players at 12 sparks
  function updateIgnitionQueue(evt){
    const readyPlayers = evt.players.filter(p => p.status === 'active' && p.sparks >= MAX_SPARKS);

    // Add new ignited players to queue (FIFO order)
    for(const p of readyPlayers){
      if(!ignitedQueue.includes(p.id)){
        ignitedQueue.push(p.id);
        log(`<span style="color:#fcd34d;font-weight:600;">${p.name} has reached 12 sparks and is queued for ignition!</span>`);
      }
    }

    // Remove players who are no longer eligible (left queue, lost sparks, etc.)
    ignitedQueue = ignitedQueue.filter(id => {
      const p = evt.players.find(pl => pl.id === id);
      return p && p.status === 'active' && p.sparks >= MAX_SPARKS;
    });
  }

  // Check if ignition can trigger this spin (cooldown check)
  function canTriggerIgnition(evt){
    const activePlayerCount = evt.players.filter(p => p.status === 'active').length;
    const cooldown = getIgnitionCooldown(activePlayerCount);
    const spinsSinceLastIgnition = evt.spinCount - lastIgnitionSpin;

    return ignitedQueue.length > 0 && spinsSinceLastIgnition >= cooldown;
  }

  // Get next ignited player from queue
  function processIgnitionQueue(evt){
    if(ignitedQueue.length === 0) return null;

    const playerId = ignitedQueue[0]; // FIFO: take first in queue
    const player = evt.players.find(p => p.id === playerId);

    if(player && player.status === 'active' && player.sparks >= MAX_SPARKS){
      ignitedQueue.shift(); // Remove from queue
      lastIgnitionSpin = evt.spinCount; // Update last ignition spin
      return player;
    }

    // Player no longer valid, remove and try next
    ignitedQueue.shift();
    return processIgnitionQueue(evt);
  }

  function buildSpinResult(evt, guaranteeWin = false, forceDead = false){
    const letters = ['C','A','R','L','O'];
    const activePlayerCount = evt.players.filter(p => p.status === 'active').length;
    const lunaOdds = getLunaBaseOdds(activePlayerCount);
    const carloLetterOdds = getCarloLetterOdds(activePlayerCount);

    const maxRetries = 100; // Prevent infinite loops
    let attempt = 0;

    while(attempt < maxRetries){
      attempt++;
      const symbols = [];

      // Build one spin attempt
      const luna = Math.random() < lunaOdds;
      const lunaIndex = luna ? Math.floor(Math.random()*5) : -1;

      for(let i=0;i<5;i++){
        if(i === lunaIndex){
          symbols.push({type:'luna'});
          continue;
        }
        const roll = Math.random();
        if(roll < carloLetterOdds){
          symbols.push({type:'letter', letter:letters[i]});
        }else{
          const p = randomWeightedPlayer(evt, i);
          if(p){
            symbols.push({type:'player', playerId:p.id, name:p.name});
          }else{
            symbols.push({type:'letter', letter:letters[i]});
          }
        }
      }

      // Check if this spin meets our requirements
      const isCarlo = detectCarlo(symbols);
      const lunaWin = detectLunaWinner(evt, symbols);
      const hitWin = detectHitWinner(evt, symbols);
      const hasWinner = isCarlo || lunaWin || hitWin;

      // Guardrail: Must have winner
      if(guaranteeWin && !hasWinner){
        continue; // Try again
      }

      // Force dead: Must NOT have winner
      if(forceDead && hasWinner){
        continue; // Try again
      }

      // Success! Return this result
      return symbols;
    }

    // Fallback: If we hit max retries, manually construct a valid result
    const symbols = [];

    if(guaranteeWin){
      // Force a 3-of-a-kind win: pick first active player and fill 3+ reels
      const activePlayers = evt.players.filter(p => p.status === 'active');
      if(activePlayers.length > 0){
        const winner = activePlayers[0];
        for(let i=0;i<5;i++){
          if(i < 3){
            symbols.push({type:'player', playerId:winner.id, name:winner.name});
          }else{
            symbols.push({type:'letter', letter:letters[i]});
          }
        }
      }
    }else if(forceDead){
      // Force a dead spin: all CARLO letters (no matches)
      for(let i=0;i<5;i++){
        symbols.push({type:'letter', letter:letters[i]});
      }
    }else{
      // Normal fallback
      const luna = Math.random() < lunaOdds;
      const lunaIndex = luna ? Math.floor(Math.random()*5) : -1;
      for(let i=0;i<5;i++){
        if(i === lunaIndex){
          symbols.push({type:'luna'});
          continue;
        }
        const roll = Math.random();
        if(roll < carloLetterOdds){
          symbols.push({type:'letter', letter:letters[i]});
        }else{
          const p = randomWeightedPlayer(evt, i);
          if(p){
            symbols.push({type:'player', playerId:p.id, name:p.name});
          }else{
            symbols.push({type:'letter', letter:letters[i]});
          }
        }
      }
    }

    return symbols;
  }

  function renderSpinResult(symbols){
    reelsEl.innerHTML = '';
    symbols.forEach(sym=>{
      const reel = document.createElement('div');
      reel.className = 'reel';
      const inner = document.createElement('div');
      inner.className = 'reel-inner';
      const div = document.createElement('div');
      if(sym.type === 'player'){
        div.className = 'reel-symbol player';
        div.textContent = sym.name;
        // Dynamic name scaling based on length
        const nameLen = sym.name.length;
        if(nameLen <= 4){
          div.classList.add('name-short');
        }else if(nameLen <= 8){
          div.classList.add('name-medium');
        }else if(nameLen <= 12){
          div.classList.add('name-long');
        }else if(nameLen <= 16){
          div.classList.add('name-very-long');
        }else{
          div.classList.add('name-extreme');
        }
      }else if(sym.type === 'letter'){
        div.className = 'reel-symbol letter';
        const img = document.createElement('img');
        img.src = LETTER_IMAGES[sym.letter] || '';
        img.alt = sym.letter;
        div.appendChild(img);
      }else if(sym.type === 'luna'){
        div.className = 'reel-symbol luna';
        const img = document.createElement('img');
        img.src = "https://i.ibb.co/8g6ZQM5C/IMG-2604.png";
        img.alt = "Luna";
        div.appendChild(img);
      }else{
        div.className = 'reel-symbol letter';
        div.textContent = '?';
      }
      inner.appendChild(div);
      reel.appendChild(inner);
      reelsEl.appendChild(reel);
    });
  }

  function detectCarlo(symbols){
    return (
      symbols[0].type==='letter' && symbols[0].letter==='C' &&
      symbols[1].type==='letter' && symbols[1].letter==='o' &&
      symbols[2].type==='letter' && symbols[2].letter==='A' &&
      symbols[3].type==='letter' && symbols[3].letter==='S' &&
      symbols[4].type==='letter' && symbols[4].letter==='T'
    );
  }

  function detectLunaWinner(evt, symbols){
    const playersById = new Map();
    evt.players.forEach(p=>playersById.set(p.id,p));
    let lunaIndex = -1;
    symbols.forEach((s,idx)=>{
      if(s.type==='luna') lunaIndex = idx;
    });
    if(lunaIndex<0) return null;
    const triples = [
      [lunaIndex-2,lunaIndex-1,lunaIndex],
      [lunaIndex-1,lunaIndex,lunaIndex+1],
      [lunaIndex,lunaIndex+1,lunaIndex+2]
    ];
    for(const triple of triples){
      const valid = triple.filter(i=>i>=0 && i<symbols.length);
      if(valid.length!==3) continue;
      const syms = valid.map(i=>symbols[i]);
      const players = syms.filter(s=>s.type==='player');
      if(players.length===0) continue;
      const countById = {};
      players.forEach(ps=>countById[ps.playerId]=(countById[ps.playerId]||0)+1);
      const idWith2 = Object.keys(countById).find(id=>countById[id]>=2);
      if(idWith2){
        const p = playersById.get(idWith2);
        if(p && p.status==='active'){
          return {player:p, hits:3, lunaIndex};
        }
      }else if(players.length===1){
        const p = playersById.get(players[0].playerId);
        if(p && p.status==='active'){
          return {player:p, hits:3, lunaIndex};
        }
      }
    }
    return null;
  }

  function detectHitWinner(evt, symbols){
    const counts = new Map();
    const playersById = new Map();
    evt.players.forEach(p=>playersById.set(p.id,p));
    symbols.forEach(s=>{
      if(s.type==='player'){
        counts.set(s.playerId,(counts.get(s.playerId)||0)+1);
      }
    });
    const candidates = [];
    counts.forEach((cnt,id)=>{
      if(cnt>=3){
        const p = playersById.get(id);
        if(p && p.status==='active'){
          candidates.push({player:p,hits:cnt});
        }
      }
    });
    if(candidates.length===0) return null;
    candidates.sort((a,b)=>{
      if(b.hits!==a.hits) return b.hits-a.hits;
      const tDiff = totalTickets(b.player)-totalTickets(a.player);
      if(tDiff!==0) return tDiff;
      return a.player.createdAt - b.player.createdAt;
    });
    return candidates[0];
  }

  function renderLeaderboard(){
    const evt = currentEvent();
    const players = evt.players;
    leaderboardBody.innerHTML = '';

    // Sort players based on current sort column and direction
    const sorted = players.slice().sort((a,b)=>{
      let aVal, bVal;

      switch(currentSortColumn){
        case 'time':
          aVal = a.createdAt;
          bVal = b.createdAt;
          break;
        case 'overall':
          aVal = calculateOverallOdds(a, evt);
          bVal = calculateOverallOdds(b, evt);
          break;
        case 'total':
          aVal = totalTickets(a);
          bVal = totalTickets(b);
          break;
        case 'slotWins':
          aVal = a.slotWins || 0;
          bVal = b.slotWins || 0;
          break;
        case 'winRate':
          aVal = overallWinRate(a);
          bVal = overallWinRate(b);
          break;
        case 'sparks':
          aVal = a.sparks || 0;
          bVal = b.sparks || 0;
          break;
        default:
          aVal = totalTickets(a);
          bVal = totalTickets(b);
      }

      // Apply sort direction
      const diff = currentSortDirection === 'desc' ? bVal - aVal : aVal - bVal;
      if(diff !== 0) return diff;

      // Tiebreaker: created time
      return a.createdAt - b.createdAt;
    });

    // Update header indicators
    document.querySelectorAll('.sortable-header').forEach(th => {
      const indicator = th.querySelector('.sort-indicator');
      if(th.dataset.sort === currentSortColumn){
        th.classList.add('active');
        indicator.textContent = currentSortDirection === 'desc' ? '' : '';
      }else{
        th.classList.remove('active');
        indicator.textContent = '';
      }
    });

    const now = Date.now();
    for(const p of sorted){
      clampPlayer(p);

      // Row 1: Player stats
      const tr1 = document.createElement('tr');
      tr1.className = 'player-row player-row-main';
      const tdTime = document.createElement('td');
      tdTime.className = 'time-cell';
      tdTime.textContent = formatTimeInQueue(now - p.createdAt);
      const tdName = document.createElement('td');
      // Add deck color identity if available
      let colorIcons = '';
      if(Array.isArray(p.colorIdentity) && p.colorIdentity.length > 0){
        const pipUrls = {
          'W': 'https://i.ibb.co/sJpHH9VZ/W.png',
          'U': 'https://i.ibb.co/0bPLHLk/U.png',
          'B': 'https://i.ibb.co/nM1ZZz3z/B.png',
          'R': 'https://i.ibb.co/NnjxnmZv/R.png',
          'G': 'https://i.ibb.co/tM5Mb1Q0/G.png',
          'C': 'https://i.ibb.co/xt4Lpn0X/C.png'
        };
        colorIcons = p.colorIdentity.map(c =>
          pipUrls[c] ? `<img src="${pipUrls[c]}" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin:0 2px;" alt="${c}"/>` : c
        ).join('');
        colorIcons = ' ' + colorIcons;
      }
      tdName.innerHTML = p.name + colorIcons + (p.status!=='active'
        ? " <span style='color:var(--red);font-size:10px;'>(AFK)</span>"
        : "");
      tdName.style.cursor = 'pointer';
      tdName.addEventListener('click',()=>openPlayerCard(p.id));
      const tdOverall = document.createElement('td');
      const overallOdds = calculateOverallOdds(p, evt);
      tdOverall.textContent = overallOdds.toFixed(1) + '%';
      tdOverall.style.fontWeight = 'bold';
      const tdTotal = document.createElement('td');
      tdTotal.textContent = totalTickets(p);
      const tdSparks = document.createElement('td');
      const sparksText = p.sparks > 0 ? `${p.sparks} / ${MAX_SPARKS}` : '';
      tdSparks.innerHTML = `<span class="sparks-count">${sparksText}</span>`;
      const tdSlotWins = document.createElement('td');
      tdSlotWins.textContent = `${p.slotWins}`;
      const tdWL = document.createElement('td');
      const winPct = overallWinRate(p);
      const winsDisplay = p.overallWins > 0 ? `+${p.overallWins}` : '0';
      const lossesDisplay = p.overallLosses > 0 ? `-${p.overallLosses}` : '0';
      tdWL.textContent = `${winsDisplay}/${lossesDisplay} (${winPct.toFixed(1)}%)`;
      if(winPct >= 60) tdWL.className = 'win-rate-good';
      else if(winPct >= 40) tdWL.className = 'win-rate-medium';
      else tdWL.className = 'win-rate-poor';
      const tdActions = document.createElement('td');
      tdActions.className='actions-cell';
      const cog = document.createElement('button');
      cog.textContent='';
      cog.title='View player card';
      cog.addEventListener('click',e=>{
        e.stopPropagation();
        openPlayerCard(p.id);
      });
      tdActions.appendChild(cog);

      tr1.appendChild(tdTime);
      tr1.appendChild(tdName);
      tr1.appendChild(tdOverall);
      tr1.appendChild(tdTotal);
      tr1.appendChild(tdSlotWins);
      tr1.appendChild(tdWL);
      tr1.appendChild(tdSparks);
      tr1.appendChild(tdActions);

      leaderboardBody.appendChild(tr1);
    }
    if(spinCountEl) spinCountEl.textContent = evt.spinCount;
    if(deadStreakEl) deadStreakEl.textContent = evt.deadSpinStreak;
    if(playerCountEl) playerCountEl.textContent = evt.players.length;

    // Update player count header
    const playerCountHeader = document.getElementById('playerCountHeader');
    if(playerCountHeader){
      const activePlayers = evt.players.filter(p => p.status === 'active');
      const afkPlayers = evt.players.filter(p => p.status !== 'active');
      playerCountHeader.textContent = `${activePlayers.length} Active${afkPlayers.length > 0 ? ` | ${afkPlayers.length} AFK` : ''}`;
    }
  }

  function openPlayerCard(playerId){
    const evt = currentEvent();
    const p = evt.players.find(x=>x.id===playerId);
    if(!p) return;
    currentPlayerCardId = playerId;
    playerCardName.textContent = p.name;
    playerCardStatus.textContent = p.status === 'active' ? 'Active' : 'AFK';

    // Render reel probability pie charts
    const reelChartsEl = document.getElementById('reelCharts');
    reelChartsEl.innerHTML = '';
    for(let i=0; i<5; i++){
      const totalForReel = evt.players.filter(pl => pl.status === 'active').reduce((sum, pl) => sum + pl.tickets[i], 0);
      const playerTickets = p.tickets[i];
      const percentage = totalForReel > 0 ? ((playerTickets / totalForReel) * 100) : 0;

      const chartDiv = document.createElement('div');
      chartDiv.className = 'reel-chart';

      const label = document.createElement('div');
      label.className = 'reel-chart-label';
      label.textContent = `Reel ${i+1}`;

      const pieChart = document.createElement('div');
      pieChart.className = 'pie-chart';
      pieChart.style.setProperty('--percentage', `${percentage}%`);
      // Gradient effect: darker at low %, lighter at high %
      const brightness = 0.3 + (percentage / 100) * 0.7; // 0.3 to 1.0
      pieChart.style.setProperty('--chart-brightness', brightness);

      const inner = document.createElement('div');
      inner.className = 'pie-chart-inner';
      inner.textContent = `${percentage.toFixed(1)}%`;

      pieChart.appendChild(inner);

      // Ticket controls below pie chart
      const ticketControls = document.createElement('div');
      ticketControls.className = 'reel-ticket-controls';

      const minusBtn = document.createElement('button');
      minusBtn.textContent = '-';
      minusBtn.className = 'ticket-btn';

      const ticketDisplay = document.createElement('span');
      ticketDisplay.className = 'ticket-count';
      ticketDisplay.textContent = playerTickets;

      const plusBtn = document.createElement('button');
      plusBtn.textContent = '+';
      plusBtn.className = 'ticket-btn';

      minusBtn.addEventListener('click', () => {
        if(p.tickets[i] > 1) {
          p.tickets[i]--;
          clampPlayer(p);
          openPlayerCard(p.id); // Refresh the card
          renderLeaderboard();
          saveAll();
        }
      });

      plusBtn.addEventListener('click', () => {
        if(p.tickets[i] < TICKET_CAP) {
          p.tickets[i]++;
          clampPlayer(p);
          openPlayerCard(p.id); // Refresh the card
          renderLeaderboard();
          saveAll();
        }
      });

      ticketControls.appendChild(minusBtn);
      ticketControls.appendChild(ticketDisplay);
      ticketControls.appendChild(plusBtn);

      chartDiv.appendChild(label);
      chartDiv.appendChild(pieChart);
      chartDiv.appendChild(ticketControls);
      reelChartsEl.appendChild(chartDiv);
    }

    // Render spark progression bulbs
    const playerSparks = p.sparks || 0;
    document.getElementById('playerSparkCount').textContent = playerSparks;

    // Light up bulbs based on spark count
    const sparkBulbs = document.querySelectorAll('.spark-bulb');
    sparkBulbs.forEach(bulb => {
      const sparkNum = parseInt(bulb.dataset.spark);
      if(playerSparks >= sparkNum){
        bulb.classList.add('lit');
      } else {
        bulb.classList.remove('lit');
      }
    });

    // Light up overflow bulbs
    const readyBulb = document.querySelector('.spark-overflow-bulb.ready');
    const ignitionBulb = document.querySelector('.spark-overflow-bulb.ignition');
    if(playerSparks >= 6){
      readyBulb.classList.add('lit');
    } else {
      readyBulb.classList.remove('lit');
    }
    if(playerSparks >= 12){
      ignitionBulb.classList.add('lit');
    } else {
      ignitionBulb.classList.remove('lit');
    }

    deckTableBody.innerHTML = '';
    const rows = [];
    p.decks.forEach(d=>{
      const total = d.wins + d.losses;
      const winRate = total>0 ? (d.wins/total)*100 : 0;
      const tr = document.createElement('tr');
      const tdColor = document.createElement('td');

      // Render color pips as images instead of text
      if(d.color){
        const pipUrls = {
          'W': 'https://i.ibb.co/sJpHH9VZ/W.png',
          'U': 'https://i.ibb.co/0bPLHLk/U.png',
          'B': 'https://i.ibb.co/nM1ZZz3z/B.png',
          'R': 'https://i.ibb.co/NnjxnmZv/R.png',
          'G': 'https://i.ibb.co/tM5Mb1Q0/G.png',
          'C': 'https://i.ibb.co/xt4Lpn0X/C.png'
        };
        tdColor.style.display = 'flex';
        tdColor.style.gap = '2px';
        tdColor.style.alignItems = 'center';
        for(const letter of d.color){
          if(pipUrls[letter]){
            const img = document.createElement('img');
            img.src = pipUrls[letter];
            img.alt = letter;
            img.style.width = '16px';
            img.style.height = '16px';
            img.style.objectFit = 'contain';
            tdColor.appendChild(img);
          }
        }
      }else{
        tdColor.textContent = '-';
      }

      const tdMatches = document.createElement('td');
      tdMatches.textContent = total;
      const tdWL = document.createElement('td');
      tdWL.textContent = `${d.wins}/${d.losses}`;
      const tdWinRate = document.createElement('td');
      tdWinRate.textContent = `${winRate.toFixed(1)}%`;

      // Render matchup data
      const tdMatchups = document.createElement('td');
      tdMatchups.style.fontSize = '10px';
      tdMatchups.style.color = 'var(--muted)';
      if(d.matchups && Object.keys(d.matchups).length > 0){
        tdMatchups.style.cursor = 'pointer';
        tdMatchups.style.userSelect = 'none';
        tdMatchups.title = 'Click to view match history';

        const pipUrls = {
          'W': 'https://i.ibb.co/sJpHH9VZ/W.png',
          'U': 'https://i.ibb.co/0bPLHLk/U.png',
          'B': 'https://i.ibb.co/nM1ZZz3z/B.png',
          'R': 'https://i.ibb.co/NnjxnmZv/R.png',
          'G': 'https://i.ibb.co/tM5Mb1Q0/G.png',
          'C': 'https://i.ibb.co/xt4Lpn0X/C.png'
        };

        // Render collapsed summary view
        const matchupLines = [];
        for(const [oppColors, stats] of Object.entries(d.matchups)){
          // Render opponent color pips
          let colorPips = '';
          for(const letter of oppColors){
            if(pipUrls[letter]){
              colorPips += `<img src="${pipUrls[letter]}" style="width:12px;height:12px;vertical-align:middle;margin:0 1px;" alt="${letter}"/>`;
            }
          }
          const matchupTotal = stats.wins + stats.losses;
          const matchupWinRate = matchupTotal > 0 ? ((stats.wins / matchupTotal) * 100).toFixed(0) : 0;
          matchupLines.push(`vs. ${colorPips}: ${stats.wins}-${stats.losses} (${matchupWinRate}%)`);
        }

        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'matchup-summary';
        summaryDiv.innerHTML = matchupLines.join('<br/>') + ' <span style="color:var(--theme-color);font-size:9px;"></span>';
        tdMatchups.appendChild(summaryDiv);

        // Create expanded detail view (initially hidden)
        const detailDiv = document.createElement('div');
        detailDiv.className = 'matchup-detail';
        detailDiv.style.display = 'none';
        detailDiv.style.marginTop = '8px';
        detailDiv.style.paddingTop = '8px';
        detailDiv.style.borderTop = '1px solid rgba(255,255,255,0.1)';

        // Collect all match history across all opponents
        const allMatches = [];
        const seenMatchIds = new Set(); // Prevent duplicate matches
        for(const [oppColors, stats] of Object.entries(d.matchups)){
          if(!stats || typeof stats !== 'object') continue; // Skip invalid stats
          if(stats.history && Array.isArray(stats.history) && stats.history.length > 0){
            stats.history.forEach(match => {
              // Validate match data and check for duplicates
              if(!match || !match.id || !match.timestamp) return;
              if(seenMatchIds.has(match.id)) return; // Skip duplicates
              seenMatchIds.add(match.id);
              if(!match.opponentColors) match.opponentColors = oppColors; // Fallback
              allMatches.push({...match, oppColors: oppColors});
            });
          }
        }

        // Sort by timestamp descending (most recent first)
        allMatches.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

        // Group by opponent color and render
        const groupedByOpponent = {};
        allMatches.forEach(match => {
          if(!groupedByOpponent[match.opponentColors]){
            groupedByOpponent[match.opponentColors] = [];
          }
          groupedByOpponent[match.opponentColors].push(match);
        });

        // Render each opponent group (in order of first appearance in sorted list)
        const processedOpponents = new Set();
        allMatches.forEach(match => {
          if(processedOpponents.has(match.opponentColors)) return;
          processedOpponents.add(match.opponentColors);

          const oppColors = match.opponentColors;
          const oppMatches = groupedByOpponent[oppColors];
          const stats = d.matchups[oppColors];

          // Opponent group header
          const groupHeader = document.createElement('div');
          groupHeader.style.cssText = 'font-weight:600;margin-bottom:4px;color:var(--text);';
          let colorPips = '';
          for(const letter of oppColors){
            if(pipUrls[letter]){
              colorPips += `<img src="${pipUrls[letter]}" style="width:12px;height:12px;vertical-align:middle;margin:0 1px;" alt="${letter}"/>`;
            }
          }
          const matchupTotal = stats.wins + stats.losses;
          const matchupWinRate = matchupTotal > 0 ? ((stats.wins / matchupTotal) * 100).toFixed(0) : 0;
          groupHeader.innerHTML = `vs. ${colorPips}`;
          detailDiv.appendChild(groupHeader);

          // Calculate match type breakdown
          const bo1Count = oppMatches.filter(m => m.matchType === 'BO1').length;
          const bo3Count = oppMatches.filter(m => m.matchType === 'BO3').length;
          const bo5Count = oppMatches.filter(m => m.matchType === 'BO5').length;

          // Statistics table with column headers
          const statsTable = document.createElement('div');
          statsTable.style.cssText = 'margin:6px 0;font-size:9px;';

          const statsHeader = document.createElement('div');
          statsHeader.style.cssText = 'display:grid;grid-template-columns:45px 30px 30px 30px 70px 70px 50px auto;gap:4px;padding:3px 4px;background:rgba(255,255,255,0.05);border-radius:2px;font-weight:700;color:var(--muted);text-align:center;';
          statsHeader.innerHTML = `<span>Total</span><span>BO1</span><span>BO3</span><span>BO5</span><span>Wins</span><span>Loss</span><span>W/L%</span><span></span>`;
          statsTable.appendChild(statsHeader);

          const statsRow = document.createElement('div');
          statsRow.style.cssText = 'display:grid;grid-template-columns:45px 30px 30px 30px 70px 70px 50px auto;gap:4px;padding:3px 4px;align-items:center;';

          // Total, BO1, BO3, BO5 (read-only)
          const totalSpan = document.createElement('span');
          totalSpan.style.cssText = 'text-align:center;';
          totalSpan.textContent = matchupTotal;

          const bo1Span = document.createElement('span');
          bo1Span.style.cssText = 'text-align:center;';
          bo1Span.textContent = bo1Count;

          const bo3Span = document.createElement('span');
          bo3Span.style.cssText = 'text-align:center;';
          bo3Span.textContent = bo3Count;

          const bo5Span = document.createElement('span');
          bo5Span.style.cssText = 'text-align:center;';
          bo5Span.textContent = bo5Count;

          // Wins with +/- controls
          const winsCell = document.createElement('div');
          winsCell.style.cssText = 'display:flex;gap:2px;align-items:center;justify-content:center;';
          const winsMinusBtn = document.createElement('button');
          winsMinusBtn.textContent = '-';
          winsMinusBtn.style.cssText = 'font-size:9px;width:16px;height:16px;padding:0;background:rgba(255,255,255,0.1);border:1px solid var(--border);border-radius:2px;cursor:pointer;color:var(--text);';
          const winsSpan = document.createElement('span');
          winsSpan.textContent = stats.wins;
          winsSpan.style.cssText = 'min-width:20px;text-align:center;';
          const winsPlusBtn = document.createElement('button');
          winsPlusBtn.textContent = '+';
          winsPlusBtn.style.cssText = 'font-size:9px;width:16px;height:16px;padding:0;background:rgba(255,255,255,0.1);border:1px solid var(--border);border-radius:2px;cursor:pointer;color:var(--text);';

          winsMinusBtn.onclick = (e) => {
            e.stopPropagation();
            if(stats.wins > 0) {
              stats.wins--;
              openPlayerCard(p.id);
              saveAll();
            }
          };
          winsPlusBtn.onclick = (e) => {
            e.stopPropagation();
            stats.wins++;
            openPlayerCard(p.id);
            saveAll();
          };

          winsCell.appendChild(winsMinusBtn);
          winsCell.appendChild(winsSpan);
          winsCell.appendChild(winsPlusBtn);

          // Losses with +/- controls
          const lossesCell = document.createElement('div');
          lossesCell.style.cssText = 'display:flex;gap:2px;align-items:center;justify-content:center;';
          const lossesMinusBtn = document.createElement('button');
          lossesMinusBtn.textContent = '-';
          lossesMinusBtn.style.cssText = 'font-size:9px;width:16px;height:16px;padding:0;background:rgba(255,255,255,0.1);border:1px solid var(--border);border-radius:2px;cursor:pointer;color:var(--text);';
          const lossesSpan = document.createElement('span');
          lossesSpan.textContent = stats.losses;
          lossesSpan.style.cssText = 'min-width:20px;text-align:center;';
          const lossesPlusBtn = document.createElement('button');
          lossesPlusBtn.textContent = '+';
          lossesPlusBtn.style.cssText = 'font-size:9px;width:16px;height:16px;padding:0;background:rgba(255,255,255,0.1);border:1px solid var(--border);border-radius:2px;cursor:pointer;color:var(--text);';

          lossesMinusBtn.onclick = (e) => {
            e.stopPropagation();
            if(stats.losses > 0) {
              stats.losses--;
              openPlayerCard(p.id);
              saveAll();
            }
          };
          lossesPlusBtn.onclick = (e) => {
            e.stopPropagation();
            stats.losses++;
            openPlayerCard(p.id);
            saveAll();
          };

          lossesCell.appendChild(lossesMinusBtn);
          lossesCell.appendChild(lossesSpan);
          lossesCell.appendChild(lossesPlusBtn);

          // Win rate (read-only)
          const winRateSpan = document.createElement('span');
          winRateSpan.style.cssText = 'text-align:center;';
          winRateSpan.textContent = matchupWinRate + '%';

          // Edit opponent colors button
          const editOppBtn = document.createElement('button');
          editOppBtn.textContent = 'Edit Opp';
          editOppBtn.style.cssText = 'font-size:9px;padding:2px 6px;background:var(--theme-color);border:none;border-radius:3px;color:#000;cursor:pointer;font-weight:600;white-space:nowrap;';
          editOppBtn.onclick = (e) => {
            e.stopPropagation();
            openOpponentColorEditDialog(p, d, oppColors, stats);
          };

          statsRow.appendChild(totalSpan);
          statsRow.appendChild(bo1Span);
          statsRow.appendChild(bo3Span);
          statsRow.appendChild(bo5Span);
          statsRow.appendChild(winsCell);
          statsRow.appendChild(lossesCell);
          statsRow.appendChild(winRateSpan);
          statsRow.appendChild(editOppBtn);
          statsTable.appendChild(statsRow);

          detailDiv.appendChild(statsTable);

          // Match history section title
          const historyTitle = document.createElement('div');
          historyTitle.style.cssText = 'font-size:9px;font-weight:600;color:var(--muted);margin:8px 0 4px 0;';
          historyTitle.textContent = 'Match History';
          detailDiv.appendChild(historyTitle);

          // Match history column headers
          const matchHistoryHeader = document.createElement('div');
          matchHistoryHeader.style.cssText = 'display:grid;grid-template-columns:50px 35px 1fr;gap:8px;padding:3px 8px;background:rgba(255,255,255,0.05);border-radius:2px;font-size:9px;font-weight:700;color:var(--muted);margin-bottom:2px;';
          matchHistoryHeader.innerHTML = `<span>Result</span><span>Type</span><span>Date/Time</span>`;
          detailDiv.appendChild(matchHistoryHeader);

          // Individual matches - limit initial render for performance
          const INITIAL_MATCH_LIMIT = 10;
          const matchContainer = document.createElement('div');
          matchContainer.className = 'match-history-container';

          const renderMatches = (matches, container, start = 0, limit = INITIAL_MATCH_LIMIT) => {
            const end = Math.min(start + limit, matches.length);
            for(let idx = start; idx < end; idx++){
              const m = matches[idx];
              const matchDiv = document.createElement('div');
              matchDiv.style.cssText = 'padding:4px 8px;margin:2px 0;background:rgba(255,255,255,0.02);border-radius:3px;font-size:9px;display:grid;grid-template-columns:50px 35px 1fr;gap:8px;align-items:center;';
              matchDiv.dataset.matchId = m.id;
              matchDiv.dataset.deckColor = d.color;

              // Column 1: Result/Score (fixed width)
              const resultSpan = document.createElement('span');
              resultSpan.style.cssText = 'font-weight:600;text-align:left;';
              if(m.matchType === 'BO1'){
                const result = m.result || 'unknown';
                const resultColor = result === 'win' ? 'var(--theme-color)' : 'var(--muted)';
                resultSpan.style.color = resultColor;
                resultSpan.textContent = result.toUpperCase();
              } else {
                const wins = m.wins || 0;
                const losses = m.losses || 0;
                resultSpan.textContent = `${wins}W-${losses}L`;
              }

              // Column 2: Match Type (fixed width)
              const typeSpan = document.createElement('span');
              typeSpan.style.cssText = 'color:var(--muted);text-align:left;';
              typeSpan.textContent = m.matchType || 'BO1';

              // Column 3: Date/Time
              const dateSpan = document.createElement('span');
              dateSpan.style.cssText = 'color:var(--muted);';
              const date = new Date(m.timestamp || Date.now());
              const dateStr = `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
              dateSpan.textContent = dateStr;

              matchDiv.appendChild(resultSpan);
              matchDiv.appendChild(typeSpan);
              matchDiv.appendChild(dateSpan);
              container.appendChild(matchDiv);
            }
            return end;
          };

          let currentRenderedCount = renderMatches(oppMatches, matchContainer);
          detailDiv.appendChild(matchContainer);

          // Show "Load More" button if there are more matches
          if(currentRenderedCount < oppMatches.length){
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.textContent = `Show ${Math.min(10, oppMatches.length - currentRenderedCount)} More (${oppMatches.length - currentRenderedCount} remaining)`;
            loadMoreBtn.style.cssText = 'font-size:9px;padding:4px 10px;background:rgba(255,255,255,0.1);border:1px solid var(--theme-color);border-radius:3px;color:var(--theme-color);cursor:pointer;margin:4px 0;width:100%;';
            loadMoreBtn.onclick = (e) => {
              e.stopPropagation();
              currentRenderedCount = renderMatches(oppMatches, matchContainer, currentRenderedCount, 10);
              if(currentRenderedCount >= oppMatches.length){
                loadMoreBtn.remove();
              } else {
                loadMoreBtn.textContent = `Show ${Math.min(10, oppMatches.length - currentRenderedCount)} More (${oppMatches.length - currentRenderedCount} remaining)`;
              }
            };
            detailDiv.appendChild(loadMoreBtn);
          }

          // Add spacing between groups
          const spacer = document.createElement('div');
          spacer.style.height = '8px';
          detailDiv.appendChild(spacer);
        });

        tdMatchups.appendChild(detailDiv);

        // Toggle expansion on click
        tdMatchups.addEventListener('click', (e) => {
          if(e.target.tagName === 'BUTTON') return; // Don't toggle if clicking edit button
          const isExpanded = detailDiv.style.display !== 'none';
          detailDiv.style.display = isExpanded ? 'none' : 'block';
          summaryDiv.querySelector('span').textContent = isExpanded ? '' : '';
        });
      }else{
        tdMatchups.textContent = '-';
      }

      const tdLast = document.createElement('td');
      tdLast.textContent = d.lastBestOf || '-';

      // Actions column with edit button
      const tdActions = document.createElement('td');
      tdActions.style.textAlign = 'center';
      const editBtn = document.createElement('button');
      editBtn.innerHTML = ' Edit';
      editBtn.title = 'Edit deck stats and colors';
      editBtn.style.cssText = 'background:rgba(255,255,255,0.1);border:1px solid var(--border);cursor:pointer;font-size:11px;padding:4px 8px;border-radius:4px;color:var(--text);opacity:0.8;transition:all 0.2s;';
      editBtn.onmouseover = () => {
        editBtn.style.opacity = '1';
        editBtn.style.background = 'rgba(255,255,255,0.15)';
      };
      editBtn.onmouseout = () => {
        editBtn.style.opacity = '0.8';
        editBtn.style.background = 'rgba(255,255,255,0.1)';
      };
      editBtn.onclick = (e) => {
        e.stopPropagation();
        openDeckEditor(p, d);
      };
      tdActions.appendChild(editBtn);

      tr.appendChild(tdColor);
      tr.appendChild(tdMatches);
      tr.appendChild(tdWL);
      tr.appendChild(tdWinRate);
      tr.appendChild(tdMatchups);
      tr.appendChild(tdLast);
      tr.appendChild(tdActions);

      rows.push({
        deck: d,
        winRate,
        total,
        wins: d.wins,
        losses: d.losses,
        color: d.color || '',
        last: d.lastBestOf || '',
        tr
      });
    });

    // Sort decks based on current sort column and direction
    rows.sort((a,b)=>{
      let aVal, bVal;
      switch(currentDeckSortColumn){
        case 'colors':
          aVal = a.color;
          bVal = b.color;
          // String comparison
          return currentDeckSortDirection === 'desc' ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
        case 'matches':
          aVal = a.total;
          bVal = b.total;
          break;
        case 'wl':
          // Sort by wins, then losses
          aVal = a.wins;
          bVal = b.wins;
          if(aVal !== bVal){
            return currentDeckSortDirection === 'desc' ? bVal - aVal : aVal - bVal;
          }
          // Tiebreaker: losses (fewer is better)
          aVal = a.losses;
          bVal = b.losses;
          return currentDeckSortDirection === 'desc' ? aVal - bVal : bVal - aVal;
        case 'winRate':
          aVal = a.winRate;
          bVal = b.winRate;
          break;
        case 'last':
          aVal = a.last;
          bVal = b.last;
          // String comparison for match type
          return currentDeckSortDirection === 'desc' ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
        default:
          aVal = a.winRate;
          bVal = b.winRate;
      }

      // Apply numeric sort direction
      const diff = currentDeckSortDirection === 'desc' ? bVal - aVal : aVal - bVal;
      if(diff !== 0) return diff;

      // Tiebreaker: total matches
      return b.total - a.total;
    });

    // By default, show only the first (most recent/highest win rate) deck
    // Mark additional rows as collapsible
    rows.forEach((r, index) => {
      if(index > 0){
        r.tr.classList.add('deck-row-collapsed');
        r.tr.style.display = 'none';
      }
      deckTableBody.appendChild(r.tr);
    });

    // Update expand icon based on current state
    if(rows.length <= 1){
      deckSectionHeader.style.cursor = 'default';
      deckExpandIcon.style.display = 'none';
    }else{
      deckSectionHeader.style.cursor = 'pointer';
      deckExpandIcon.style.display = 'inline';
      deckExpandIcon.textContent = '';
    }

    // Update deck table sort indicators
    const deckHeaders = deckTableWrapper.querySelectorAll('.sortable-header[data-deck-sort]');
    deckHeaders.forEach(th => {
      const indicator = th.querySelector('.sort-indicator');
      if(th.dataset.deckSort === currentDeckSortColumn){
        th.classList.add('active');
        indicator.textContent = currentDeckSortDirection === 'desc' ? '' : '';
      }else{
        th.classList.remove('active');
        indicator.textContent = '';
      }
    });

    // Show/hide export deck button based on whether player has a deck list
    exportPlayerDeckBtn.style.display = hasValidDeckList(p) ? 'inline-block' : 'none';

    playerOverlay.classList.add('show');
  }

  // Inline editing for match opponent colors
  function openOpponentColorEditDialog(player, deck, oldOppColors, stats){
    const dialogContainer = document.createElement('div');
    dialogContainer.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--bg);border:2px solid var(--theme-color);border-radius:8px;padding:20px;z-index:100000;max-width:400px;box-shadow:0 8px 24px rgba(0,0,0,0.8);';

    const title = document.createElement('div');
    title.style.cssText = 'font-weight:700;font-size:14px;margin-bottom:12px;color:var(--text);';
    title.textContent = 'Edit Opponent Colors';
    dialogContainer.appendChild(title);

    const instruction = document.createElement('div');
    instruction.style.cssText = 'font-size:11px;color:var(--muted);margin-bottom:12px;';
    instruction.textContent = 'This will update ALL matches against this opponent to new colors.';
    dialogContainer.appendChild(instruction);

    const colorChipsDiv = document.createElement('div');
    colorChipsDiv.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;margin-bottom:16px;';

    const currentColors = new Set(oldOppColors.split(''));
    ['W', 'U', 'B', 'R', 'G', 'C'].forEach(color => {
      const chip = document.createElement('div');
      chip.className = 'color-chip';
      if(currentColors.has(color)) chip.classList.add('active');
      chip.dataset.color = color;
      chip.textContent = color;
      chip.style.cssText = 'cursor:pointer;padding:8px 12px;font-size:12px;';
      chip.onclick = () => chip.classList.toggle('active');
      colorChipsDiv.appendChild(chip);
    });
    dialogContainer.appendChild(colorChipsDiv);

    const btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;';

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = 'font-size:11px;padding:6px 12px;background:rgba(255,255,255,0.1);border:1px solid var(--border);border-radius:4px;color:var(--text);cursor:pointer;';
    cancelBtn.onclick = () => {
      document.body.removeChild(dialogContainer);
      document.body.removeChild(overlay);
    };

    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    saveBtn.style.cssText = 'font-size:11px;padding:6px 12px;background:var(--theme-color);border:none;border-radius:4px;color:#000;cursor:pointer;font-weight:600;';
    saveBtn.onclick = () => {
      const activeChips = colorChipsDiv.querySelectorAll('.color-chip.active');
      const newOppColors = Array.from(activeChips).map(c => c.dataset.color).sort().join('');

      if(newOppColors && newOppColors !== oldOppColors){
        const evt = currentEvent();
        const p = evt.players.find(x => x.id === player.id);
        if(!p) return;
        const d = p.decks.find(x => x.color === deck.color);
        if(!d) return;

        // Move all matches from old opponent to new opponent
        if(d.matchups[oldOppColors]){
          const oldMatchups = d.matchups[oldOppColors];

          // Create new opponent group if doesn't exist
          if(!d.matchups[newOppColors]){
            d.matchups[newOppColors] = {wins: 0, losses: 0, history: []};
          }

          // Transfer stats and history
          d.matchups[newOppColors].wins += oldMatchups.wins;
          d.matchups[newOppColors].losses += oldMatchups.losses;

          if(oldMatchups.history){
            oldMatchups.history.forEach(match => {
              match.opponentColors = newOppColors;
              d.matchups[newOppColors].history.push(match);
            });
          }

          // Delete old matchup group
          delete d.matchups[oldOppColors];

          openPlayerCard(p.id);
          saveAll();
        }
      }

      document.body.removeChild(dialogContainer);
      document.body.removeChild(overlay);
    };

    btnRow.appendChild(cancelBtn);
    btnRow.appendChild(saveBtn);
    dialogContainer.appendChild(btnRow);

    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:99999;';
    overlay.onclick = () => {
      document.body.removeChild(dialogContainer);
      document.body.removeChild(overlay);
    };

    document.body.appendChild(overlay);
    document.body.appendChild(dialogContainer);
  }

  function openMatchEditDialog(player, deck, match){
    const pipUrls = {
      'W': 'https://i.ibb.co/sJpHH9VZ/W.png',
      'U': 'https://i.ibb.co/0bPLHLk/U.png',
      'B': 'https://i.ibb.co/nM1ZZz3z/B.png',
      'R': 'https://i.ibb.co/NnjxnmZv/R.png',
      'G': 'https://i.ibb.co/tM5Mb1Q0/G.png',
      'C': 'https://i.ibb.co/xt4Lpn0X/C.png'
    };

    // Find the match div
    const matchDiv = document.querySelector(`[data-match-id="${match.id}"][data-deck-color="${deck.color}"]`);
    if(!matchDiv) return;

    const originalHTML = matchDiv.innerHTML;
    const oldOpponentColors = match.opponentColors;

    // Create inline editing UI
    matchDiv.innerHTML = '';
    matchDiv.style.flexDirection = 'column';
    matchDiv.style.gap = '6px';

    const instructionDiv = document.createElement('div');
    instructionDiv.style.cssText = 'font-size:9px;color:var(--muted);';
    instructionDiv.textContent = 'Select new opponent colors:';
    matchDiv.appendChild(instructionDiv);

    const colorChipsDiv = document.createElement('div');
    colorChipsDiv.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;';

    // Create color chips
    const currentColors = new Set(oldOpponentColors.split(''));
    ['W', 'U', 'B', 'R', 'G', 'C'].forEach(color => {
      const chip = document.createElement('div');
      chip.className = 'color-chip';
      if(currentColors.has(color)) chip.classList.add('active');
      chip.dataset.color = color;
      chip.textContent = color;
      chip.style.cssText = 'cursor:pointer;padding:4px 8px;font-size:10px;';
      chip.onclick = () => chip.classList.toggle('active');
      colorChipsDiv.appendChild(chip);
    });
    matchDiv.appendChild(colorChipsDiv);

    const btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:6px;margin-top:4px;';

    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    saveBtn.style.cssText = 'font-size:9px;padding:3px 8px;background:var(--theme-color);border:none;border-radius:3px;color:#000;cursor:pointer;font-weight:600;';
    saveBtn.onclick = () => {
      // Collect new opponent colors
      const activeChips = colorChipsDiv.querySelectorAll('.color-chip.active');
      const newOpponentColors = Array.from(activeChips).map(c => c.dataset.color).sort().join('');

      if(newOpponentColors === oldOpponentColors){
        // No change, just restore
        matchDiv.innerHTML = originalHTML;
        matchDiv.style.flexDirection = '';
        matchDiv.style.gap = '';
        return;
      }

      // Update matchup data
      const evt = currentEvent();
      const p = evt.players.find(x => x.id === player.id);
      if(!p) return;
      const d = p.decks.find(x => x.color === deck.color);
      if(!d) return;

      // Remove from old opponent group
      if(d.matchups[oldOpponentColors]){
        const history = d.matchups[oldOpponentColors].history;
        const matchIndex = history.findIndex(m => m.id === match.id);
        if(matchIndex >= 0){
          const removedMatch = history.splice(matchIndex, 1)[0];

          // Update wins/losses counts for old opponent
          if(removedMatch.matchType === 'BO1'){
            if(removedMatch.result === 'win'){
              d.matchups[oldOpponentColors].wins = Math.max(0, d.matchups[oldOpponentColors].wins - 1);
            } else {
              d.matchups[oldOpponentColors].losses = Math.max(0, d.matchups[oldOpponentColors].losses - 1);
            }
          } else {
            d.matchups[oldOpponentColors].wins = Math.max(0, d.matchups[oldOpponentColors].wins - removedMatch.wins);
            d.matchups[oldOpponentColors].losses = Math.max(0, d.matchups[oldOpponentColors].losses - removedMatch.losses);
          }

          // Clean up empty matchup group
          if(d.matchups[oldOpponentColors].wins === 0 && d.matchups[oldOpponentColors].losses === 0){
            delete d.matchups[oldOpponentColors];
          }
        }
      }

      // Add to new opponent group (or skip if empty)
      if(newOpponentColors){
        if(!d.matchups[newOpponentColors]){
          d.matchups[newOpponentColors] = {wins: 0, losses: 0, history: []};
        }

        // Update match data
        match.opponentColors = newOpponentColors;

        // Add to new opponent's history
        d.matchups[newOpponentColors].history.push(match);

        // Update wins/losses counts for new opponent
        if(match.matchType === 'BO1'){
          if(match.result === 'win'){
            d.matchups[newOpponentColors].wins += 1;
          } else {
            d.matchups[newOpponentColors].losses += 1;
          }
        } else {
          d.matchups[newOpponentColors].wins += match.wins;
          d.matchups[newOpponentColors].losses += match.losses;
        }
      }

      // Save and refresh
      saveAll();
      openPlayerCard(player.id); // Refresh the entire player card
      log(`Updated match opponent colors from ${oldOpponentColors || 'none'} to ${newOpponentColors || 'none'} for ${player.name}'s ${deck.color} deck`);
    };

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = 'font-size:9px;padding:3px 8px;background:rgba(255,255,255,0.1);border:none;border-radius:3px;color:var(--text);cursor:pointer;';
    cancelBtn.onclick = () => {
      matchDiv.innerHTML = originalHTML;
      matchDiv.style.flexDirection = '';
      matchDiv.style.gap = '';
    };

    btnRow.appendChild(saveBtn);
    btnRow.appendChild(cancelBtn);
    matchDiv.appendChild(btnRow);
  }

  exportPlayerDeckBtn.addEventListener('click',()=>{
    if(currentPlayerCardId===null) return;
    const evt = currentEvent();
    const p = evt.players.find(x=>x.id===currentPlayerCardId);
    if(!p) return;
    exportDeckToClipboard(p, exportPlayerDeckBtn);
  });

  toggleAfkBtn.addEventListener('click',()=>{
    if(currentPlayerCardId===null) return;
    const evt = currentEvent();
    const p = evt.players.find(x=>x.id===currentPlayerCardId);
    if(!p) return;
    p.status = (p.status==='active' ? 'afk' : 'active');
    log(`${p.name} is now ${p.status.toUpperCase()}.`);
    playerOverlay.classList.remove('show');
    renderLeaderboard();
    saveAll();
  });
  removePlayerBtn.addEventListener('click',()=>{
    if(currentPlayerCardId===null) return;
    const evt = currentEvent();
    const idx = evt.players.findIndex(x=>x.id===currentPlayerCardId);
    if(idx>=0){
      const removed = evt.players.splice(idx,1)[0];
      log(`Removed ${removed.name} from the session.`);
    }
    playerOverlay.classList.remove('show');
    currentPlayerCardId = null;
    renderLeaderboard();
    saveAll();
  });
  closePlayerCardBtn.addEventListener('click',()=>{
    playerOverlay.classList.remove('show');
    currentPlayerCardId=null;
    saveAll();
  });

  // Toggle deck list expand/collapse
  deckSectionHeader.addEventListener('click', () => {
    const collapsedRows = deckTableBody.querySelectorAll('.deck-row-collapsed');
    if(collapsedRows.length === 0) return; // No rows to expand

    const isCurrentlyCollapsed = collapsedRows[0].style.display === 'none';

    collapsedRows.forEach(row => {
      row.style.display = isCurrentlyCollapsed ? '' : 'none';
    });

    deckExpandIcon.textContent = isCurrentlyCollapsed ? '' : '';
  });

  // History log accordion
  historyHeader.addEventListener('click', () => {
    const isCurrentlyCollapsed = logEl.style.display === 'none';
    logEl.style.display = isCurrentlyCollapsed ? '' : 'none';
    historyExpandIcon.textContent = isCurrentlyCollapsed ? '' : '';
  });

  // Leaderboard column sorting
  document.querySelectorAll('.sortable-header[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      const sortColumn = th.dataset.sort;

      // If clicking the same column, toggle direction
      if(currentSortColumn === sortColumn){
        currentSortDirection = currentSortDirection === 'desc' ? 'asc' : 'desc';
      }else{
        // New column: default to descending (highest first)
        currentSortColumn = sortColumn;
        currentSortDirection = 'desc';
      }

      renderLeaderboard();
    });
  });

  // Deck table column sorting
  document.addEventListener('click', (e) => {
    const th = e.target.closest('.sortable-header[data-deck-sort]');
    if(!th) return;

    const sortColumn = th.dataset.deckSort;

    // If clicking the same column, toggle direction
    if(currentDeckSortColumn === sortColumn){
      currentDeckSortDirection = currentDeckSortDirection === 'desc' ? 'asc' : 'desc';
    }else{
      // New column: default to descending (highest first)
      currentDeckSortColumn = sortColumn;
      currentDeckSortDirection = 'desc';
    }

    // Refresh the currently open player card to apply new sorting
    if(currentPlayerCardId !== null){
      const evt = currentEvent();
      const p = evt.players.find(x => x.id === currentPlayerCardId);
      if(p) openPlayerCard(p.id);
    }
  });

  // Open deck editor
  function openDeckEditor(player, deck){
    currentEditingPlayer = player;
    currentEditingDeck = deck;

    // Set color chips
    deckEditorColorSet.clear();
    Array.from(deckEditorColorChips.children).forEach(ch => ch.classList.remove('active'));
    if(deck.color){
      for(const c of deck.color){
        deckEditorColorSet.add(c);
        const chip = Array.from(deckEditorColorChips.children).find(ch => ch.dataset.color === c);
        if(chip) chip.classList.add('active');
      }
    }

    // Set wins/losses
    deckEditorWins.value = deck.wins;
    deckEditorLosses.value = deck.losses;

    // Set match type
    if(deck.lastBestOf){
      deckEditorMatchType.value = deck.lastBestOf;
    }

    deckEditorOverlay.classList.add('show');
  }

  // Deck editor color chip toggling
  deckEditorColorChips.addEventListener('click', e => {
    const chip = e.target.closest('.color-chip');
    if(!chip) return;
    const c = chip.dataset.color;
    if(deckEditorColorSet.has(c)){
      deckEditorColorSet.delete(c);
      chip.classList.remove('active');
    }else{
      deckEditorColorSet.add(c);
      chip.classList.add('active');
    }
  });

  // Deck editor +/- buttons
  deckEditorWinsUp.addEventListener('click', () => {
    deckEditorWins.value = Math.max(0, parseInt(deckEditorWins.value, 10) || 0) + 1;
  });
  deckEditorWinsDown.addEventListener('click', () => {
    deckEditorWins.value = Math.max(0, (parseInt(deckEditorWins.value, 10) || 0) - 1);
  });
  deckEditorLossesUp.addEventListener('click', () => {
    deckEditorLosses.value = Math.max(0, parseInt(deckEditorLosses.value, 10) || 0) + 1;
  });
  deckEditorLossesDown.addEventListener('click', () => {
    deckEditorLosses.value = Math.max(0, (parseInt(deckEditorLosses.value, 10) || 0) - 1);
  });

  // Save deck changes
  deckEditorSaveBtn.addEventListener('click', () => {
    if(!currentEditingPlayer || !currentEditingDeck) return;

    const newColors = Array.from(deckEditorColorSet).join('');
    const newWins = Math.max(0, parseInt(deckEditorWins.value, 10) || 0);
    const newLosses = Math.max(0, parseInt(deckEditorLosses.value, 10) || 0);
    const newMatchType = deckEditorMatchType.value;

    // Calculate the delta for overall stats
    const winsDelta = newWins - currentEditingDeck.wins;
    const lossesDelta = newLosses - currentEditingDeck.losses;

    // Update overall stats
    currentEditingPlayer.overallWins += winsDelta;
    currentEditingPlayer.overallLosses += lossesDelta;

    // If colors changed, we need to move the deck
    if(newColors !== currentEditingDeck.color){
      // Remove old deck
      const idx = currentEditingPlayer.decks.indexOf(currentEditingDeck);
      if(idx >= 0){
        currentEditingPlayer.decks.splice(idx, 1);
      }

      // Find or create deck with new colors
      let targetDeck = currentEditingPlayer.decks.find(d => d.color === newColors);
      if(!targetDeck){
        targetDeck = {color: newColors, wins: 0, losses: 0, lastBestOf: null, matchups: {}};
        currentEditingPlayer.decks.push(targetDeck);
      }
      targetDeck.wins += newWins;
      targetDeck.losses += newLosses;
      targetDeck.lastBestOf = newMatchType;

      log(`${currentEditingPlayer.name}: Moved deck ${currentEditingDeck.color}  ${newColors} (${newWins}W/${newLosses}L)`);
    }else{
      // Just update the existing deck
      currentEditingDeck.wins = newWins;
      currentEditingDeck.losses = newLosses;
      currentEditingDeck.lastBestOf = newMatchType;

      log(`${currentEditingPlayer.name}: Updated deck ${currentEditingDeck.color} to ${newWins}W/${newLosses}L`);
    }

    deckEditorOverlay.classList.remove('show');
    currentEditingPlayer = null;
    currentEditingDeck = null;
    renderLeaderboard();
    saveAll();

    // Refresh player card if it's still open
    if(currentPlayerCardId !== null){
      const evt = currentEvent();
      const p = evt.players.find(x => x.id === currentPlayerCardId);
      if(p) showPlayerCard(p);
    }
  });

  // Delete deck
  deckEditorDeleteBtn.addEventListener('click', () => {
    if(!currentEditingPlayer || !currentEditingDeck) return;
    if(!confirm(`Delete ${currentEditingDeck.color} deck (${currentEditingDeck.wins}W/${currentEditingDeck.losses}L)?`)) return;

    // Update overall stats
    currentEditingPlayer.overallWins -= currentEditingDeck.wins;
    currentEditingPlayer.overallLosses -= currentEditingDeck.losses;

    // Remove deck
    const idx = currentEditingPlayer.decks.indexOf(currentEditingDeck);
    if(idx >= 0){
      currentEditingPlayer.decks.splice(idx, 1);
      log(`${currentEditingPlayer.name}: Deleted deck ${currentEditingDeck.color}`);
    }

    deckEditorOverlay.classList.remove('show');
    currentEditingPlayer = null;
    currentEditingDeck = null;
    renderLeaderboard();
    saveAll();

    // Refresh player card if it's still open
    if(currentPlayerCardId !== null){
      const evt = currentEvent();
      const p = evt.players.find(x => x.id === currentPlayerCardId);
      if(p) showPlayerCard(p);
    }
  });

  // Close deck editor
  closeDeckEditorBtn.addEventListener('click', () => {
    deckEditorOverlay.classList.remove('show');
    currentEditingPlayer = null;
    currentEditingDeck = null;
    saveAll();
  });

  // Close deck editor when clicking outside
  deckEditorOverlay.addEventListener('click', (e) => {
    if(e.target === deckEditorOverlay){
      deckEditorOverlay.classList.remove('show');
      currentEditingPlayer = null;
      currentEditingDeck = null;
    }
  });

  // Deck Import - Color chip selection
  deckImportColorChips.addEventListener('click', e => {
    const chip = e.target.closest('.color-chip');
    if(!chip) return;
    const c = chip.dataset.color;
    if(deckImportColorSet.has(c)){
      deckImportColorSet.delete(c);
      chip.classList.remove('active');
    }else{
      deckImportColorSet.add(c);
      chip.classList.add('active');
    }
  });

  // Deck Import - Import from clipboard
  deckImportSaveBtn.addEventListener('click', async () => {
    if(!pendingImportPlayer) return;

    // Must select at least one color
    if(deckImportColorSet.size === 0){
      alert('Please select at least one color for the deck identity.');
      return;
    }

    // Read deck list from clipboard
    let deckText = '';
    try {
      deckText = await navigator.clipboard.readText();
    } catch(err) {
      console.error('Failed to read clipboard:', err);
      alert('Failed to read from clipboard. Please ensure you have copied your deck list.');
      return;
    }

    if(!deckText || deckText.trim().length === 0){
      alert('Clipboard is empty. Please copy your MTG Arena deck list first.');
      return;
    }

    const evt = currentEvent();
    const player = evt.players.find(p => p.id === pendingImportPlayer.id);
    if(!player) return;

    // Get selected colors in WUBRG order
    const colors = Array.from(deckImportColorSet).sort((a,b) => {
      const order = ['W','U','B','R','G','C'];
      return order.indexOf(a) - order.indexOf(b);
    });

    // Check for duplicate name:color combination
    const fullName = `${player.baseName}:${colors.join('')}`;
    const duplicate = evt.players.find(p =>
      p.id !== player.id && p.name.toLowerCase() === fullName.toLowerCase()
    );
    if(duplicate){
      alert(`${fullName} is already in the queue. Please use a different color identity or player name.`);
      return;
    }

    // Update player with color identity
    player.name = fullName;
    player.colorIdentity = colors;
    player.deckList = deckText.trim();

    // Create initial deck entry
    player.decks.push({
      color: colors.join(''),
      wins: 0,
      losses: 0,
      matchups: {},
      lastBestOf: 'BO3'
    });

    log(`Imported ${colors.join('')} deck for ${player.baseName}`);

    deckImportOverlay.classList.remove('show');
    pendingImportPlayer = null;
    renderLeaderboard();
    saveAll();
  });

  // Deck Import - Skip (removes player from queue)
  deckImportSkipBtn.addEventListener('click', () => {
    if(pendingImportPlayer){
      const evt = currentEvent();
      const idx = evt.players.findIndex(p => p.id === pendingImportPlayer.id);
      if(idx >= 0){
        const removed = evt.players.splice(idx, 1)[0];
        log(`${removed.baseName || removed.name} skipped deck import and was removed.`);
      }
    }
    deckImportOverlay.classList.remove('show');
    pendingImportPlayer = null;
    renderLeaderboard();
    saveAll();
  });

  // Close player card when clicking outside
  playerOverlay.addEventListener('click',(e)=>{
    if(e.target === playerOverlay){
      playerOverlay.classList.remove('show');
      currentPlayerCardId=null;
    }
  });

  function handleWinnerBanner(player, reason, hits, isLuna){
    const evt = currentEvent();
    evt.deadSpinStreak = 0;
    evt.lastSpinWasWinner = true;
    evt.spinCount++;
    player.slotGames = (player.slotGames||0) + 1;
    player.slotWins = (player.slotWins||0) + 1;
    clampPlayer(player);
    pendingWinner = player;
    currentWinnerMeta = {reason,hits};
    winnerLunaSticker.style.display = isLuna ? 'block' : 'none';

    winnerNameEl.textContent = player.name;
    if(reason==='luna'){
      winnerHeading.textContent = 'LUNA LUCK!';
      winnerMetaEl.textContent = `${player.name} wins with Luna Luck!`;
    }else if(reason==='ignited'){
      winnerHeading.textContent = 'IGNITED!';
      winnerMetaEl.textContent = `${player.name} has ${MAX_SPARKS} sparks & has been Ignited.`;
    }else if(reason==='carlo'){
      winnerHeading.textContent = 'CoAST PICK';
      winnerMetaEl.textContent = `CoAST hit  streamer plays their own deck this round.`;
    }else{
      winnerHeading.textContent = 'WINNER';
      if(hits>=5){
        winnerMetaEl.textContent = `${player.name} hit 5 symbols  high-odds pick!`;
      }else if(hits===4){
        winnerMetaEl.textContent = `${player.name} hit 4 symbols  strong roll.`;
      }else{
        winnerMetaEl.textContent = `${player.name}'s deck is up next.`;
      }
    }
    winnerOverlay.classList.add('show');
  }

  // Generate dynamic opponent color selectors based on match type and matches played
  function regenerateOpponentColorSelectors(){
    const matchesPlayed = Math.max(0, parseInt(matchesPlayedInput.value, 10) || 0);
    const activeMatchType = matchTypeChoice.querySelector('.queue-chip.active');
    const matchType = activeMatchType ? activeMatchType.dataset.matchType : 'BO3';

    // Clear existing content
    opponentColorsContainer.innerHTML = '';

    if(matchesPlayed === 0){
      opponentColorsContainer.innerHTML = '<div class="finish-label" style="color:var(--muted);font-size:11px;">Add matches played to enter opponent colors</div>';
      return;
    }

    if(matchType === 'BO1'){
      // BO1: One opponent color selector per game (match = game for BO1)
      // Limit to prevent DOM overflow (max 20 games per BO1 run)
      const MAX_BO1_GAMES = 20;
      if(matchesPlayed > MAX_BO1_GAMES){
        opponentColorsContainer.innerHTML = `<div class="finish-label" style="color:var(--muted);font-size:11px;">Max ${MAX_BO1_GAMES} games per BO1 run. Please adjust matches played.</div>`;
        return;
      }

      const labelDiv = document.createElement('div');
      labelDiv.className = 'finish-label';
      labelDiv.textContent = 'Opponent Colors (Required - one per game)';
      opponentColorsContainer.appendChild(labelDiv);

      // Create scrollable container for opponent groups
      const scrollContainer = document.createElement('div');
      scrollContainer.style.cssText = 'max-height:300px;overflow-y:auto;overflow-x:hidden;margin-top:8px;padding-right:4px;';
      scrollContainer.className = 'opponent-scroll-container';

      for(let i = 0; i < matchesPlayed; i++){
        const gameDiv = document.createElement('div');
        gameDiv.className = 'opponent-game-group';
        gameDiv.style.cssText = 'margin-bottom:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:4px;';

        const gameLabelDiv = document.createElement('div');
        gameLabelDiv.textContent = `Game ${i + 1}`;
        gameLabelDiv.style.cssText = 'font-size:10px;color:var(--muted);margin-bottom:4px;';

        const chipsDiv = document.createElement('div');
        chipsDiv.className = 'opponent-color-chips';
        chipsDiv.dataset.gameIndex = i;
        chipsDiv.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;justify-content:center;';

        // Create color chips
        ['W', 'U', 'B', 'R', 'G', 'C'].forEach(color => {
          const chip = document.createElement('div');
          chip.className = 'color-chip';
          chip.dataset.color = color;
          chip.textContent = color;
          chipsDiv.appendChild(chip);
        });

        gameDiv.appendChild(gameLabelDiv);
        gameDiv.appendChild(chipsDiv);
        scrollContainer.appendChild(gameDiv);
      }

      opponentColorsContainer.appendChild(scrollContainer);
    } else {
      // BO3/BO5: One opponent color selector per match
      const labelDiv = document.createElement('div');
      labelDiv.className = 'finish-label';
      labelDiv.textContent = 'Opponent Colors (Required - one per match)';
      opponentColorsContainer.appendChild(labelDiv);

      // Create scrollable container for opponent groups
      const scrollContainer = document.createElement('div');
      scrollContainer.style.cssText = 'max-height:300px;overflow-y:auto;overflow-x:hidden;margin-top:8px;padding-right:4px;';
      scrollContainer.className = 'opponent-scroll-container';

      for(let i = 0; i < matchesPlayed; i++){
        const matchDiv = document.createElement('div');
        matchDiv.className = 'opponent-game-group';
        matchDiv.style.cssText = 'margin-bottom:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:4px;';

        const matchLabelDiv = document.createElement('div');
        matchLabelDiv.textContent = `Match ${i + 1}`;
        matchLabelDiv.style.cssText = 'font-size:10px;color:var(--muted);margin-bottom:4px;';

        const chipsDiv = document.createElement('div');
        chipsDiv.className = 'opponent-color-chips';
        chipsDiv.dataset.gameIndex = i;
        chipsDiv.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;justify-content:center;';

        // Create color chips
        ['W', 'U', 'B', 'R', 'G', 'C'].forEach(color => {
          const chip = document.createElement('div');
          chip.className = 'color-chip';
          chip.dataset.color = color;
          chip.textContent = color;
          chipsDiv.appendChild(chip);
        });

        matchDiv.appendChild(matchLabelDiv);
        matchDiv.appendChild(chipsDiv);
        scrollContainer.appendChild(matchDiv);
      }

      opponentColorsContainer.appendChild(scrollContainer);
    }
  }

  function finishRunPrompt(player){
    const evt = currentEvent();
    const hits = (currentWinnerMeta && currentWinnerMeta.hits) || 3;
    evt.currentRun = {
      playerId: player.id,
      bonusHits: hits // Store hits for later bonus prompt
    };
    // Reset all inputs
    matchesPlayedInput.value = "0";
    runWinsInput.value = "0";
    runLossesInput.value = "0";

    // Reset match type to BO3
    Array.from(matchTypeChoice.children).forEach(ch=>{
      ch.classList.toggle('active', ch.dataset.matchType === 'BO3');
    });
    regenerateOpponentColorSelectors(); // Generate initial opponent selectors

    // Reset bonus choice to tickets
    Array.from(bonusChoice.children).forEach(ch=>{
      ch.classList.toggle('active', ch.dataset.choice === 'tickets');
    });

    finishSaveBtn.disabled = false;
    finishOverlay.classList.add('show');
  }

  winnerExportPlayBtn.addEventListener('click',()=>{
    if(!pendingWinner) return;
    const p = pendingWinner;
    // Export deck to clipboard if available
    if(hasValidDeckList(p)){
      exportDeckToClipboard(p, winnerExportPlayBtn);
    }
    // Trigger report dialog
    pendingWinner = null;
    winnerOverlay.classList.remove('show');
    hasUnreportedGame = true;
    unreportedGamePlayer = p;
    finishRunPrompt(p);
  });

  winnerSkipBtn.addEventListener('click',()=>{
    const evt = currentEvent();
    if(!pendingWinner) return;

    // Show prompt: Remove or Mark AFK
    const choice = confirm(`What would you like to do with ${pendingWinner.name}?\n\nOK = Remove from queue\nCancel = Mark as AFK`);

    if(choice){
      // Remove player
      log(`Winner ${pendingWinner.name} removed from queue.`);
      const idx = evt.players.findIndex(x=>x.id===pendingWinner.id);
      if(idx>=0) evt.players.splice(idx,1);
    } else {
      // Mark as AFK
      pendingWinner.status = 'afk';
      log(`Winner ${pendingWinner.name} marked as AFK.`);
    }

    pendingWinner=null;
    hasUnreportedGame = false;
    unreportedGamePlayer = null;
    winnerOverlay.classList.remove('show');
    renderLeaderboard();
    saveAll();
  });

  // Color chip selection removed - color identity now stored with player during import

  // Event delegation for dynamically generated opponent color chips
  opponentColorsContainer.addEventListener('click',e=>{
    const chip = e.target.closest('.color-chip');
    if(!chip) return;
    chip.classList.toggle('active');
  });

  // Bonus choice selection in overlay
  bonusChoice.addEventListener('click',e=>{
    const chip = e.target.closest('.queue-chip');
    if(!chip) return;
    Array.from(bonusChoice.children).forEach(ch=>{
      ch.classList.toggle('active', ch===chip);
    });
  });

  finishCancelBtn.addEventListener('click',()=>{
    finishOverlay.classList.remove('show');
    // Note: Don't clear hasUnreportedGame here - user still needs to report
    // The unreported game check will re-trigger on next spin attempt
    saveAll();
  });

  finishSaveBtn.addEventListener('click',()=>{
    const evt = currentEvent();
    if(!evt.currentRun) return;

    // Prevent double-click by disabling button immediately
    if(finishSaveBtn.disabled) return;
    finishSaveBtn.disabled = true;

    const run = evt.currentRun;
    const player = evt.players.find(p=>p.id===run.playerId);
    if(!player){
      evt.currentRun=null;
      finishOverlay.classList.remove('show');
      finishSaveBtn.disabled = false;
      return;
    }
    const wins = Math.max(0,parseInt(runWinsInput.value,10)||0);
    const losses = Math.max(0,parseInt(runLossesInput.value,10)||0);
    const matchesPlayed = Math.max(0,parseInt(matchesPlayedInput.value,10)||0);
    const colors = player.colorIdentity ? player.colorIdentity.join('') : '';  // Use stored color identity
    const activeMatchType = matchTypeChoice.querySelector('.queue-chip.active');
    const matchType = activeMatchType ? activeMatchType.dataset.matchType : 'BO3';

    // Collect opponent colors from dynamic selectors
    let opponentColorsByGame = []; // Array for BO1, single element for BO3/BO5
    const opponentChipGroups = opponentColorsContainer.querySelectorAll('.opponent-color-chips');
    opponentChipGroups.forEach(group => {
      const activeChips = Array.from(group.querySelectorAll('.color-chip.active'));
      const gameColors = activeChips.map(chip => chip.dataset.color).sort().join('');
      if(gameColors){
        opponentColorsByGame.push(gameColors);
      }
    });

    player.overallWins += wins;
    player.overallLosses += losses;
    if(colors){
      let deck = player.decks.find(d=>d.color===colors);
      if(!deck){
        // Check 32 deck limit - supports all MTG color identities:
        // 5 mono (W,U,B,R,G) + 10 dual + 10 triple + 5 four-color + 1 five-color + 1 colorless
        if(player.decks.length >= 32){
          // Remove deck with lowest win percentage
          const sorted = player.decks.slice().sort((a,b)=>{
            const winRateA = (a.wins+a.losses)>0 ? a.wins/(a.wins+a.losses) : 0;
            const winRateB = (b.wins+b.losses)>0 ? b.wins/(b.wins+b.losses) : 0;
            if(winRateA !== winRateB) return winRateA - winRateB;
            return (a.wins+a.losses) - (b.wins+b.losses);
          });
          const toRemove = sorted[0];
          const idx = player.decks.indexOf(toRemove);
          if(idx >= 0){
            player.decks.splice(idx, 1);
            log(`${player.name} reached 32 deck limit. Removed deck ${toRemove.color} (lowest win rate).`);
          }
        }
        deck = {color:colors,wins:0,losses:0,lastBestOf:null,matchups:{}};
        player.decks.push(deck);
      }
      deck.wins += wins;
      deck.losses += losses;
      deck.lastBestOf = matchType;

      // Track matchup data against opponent colors if provided
      if(opponentColorsByGame.length > 0){
        if(!deck.matchups) deck.matchups = {};  // Initialize if old deck doesn't have matchups
        const timestamp = Date.now();

        if(matchType === 'BO1'){
          // BO1: Track each game individually
          opponentColorsByGame.forEach((oppColors, index) => {
            if(!deck.matchups[oppColors]){
              deck.matchups[oppColors] = {wins:0, losses:0, history:[]};
            }
            if(!deck.matchups[oppColors].history) deck.matchups[oppColors].history = []; // Migrate old data

            // First 'wins' games are wins, remaining are losses
            const isWin = index < wins;
            if(isWin){
              deck.matchups[oppColors].wins += 1;
            } else {
              deck.matchups[oppColors].losses += 1;
            }

            // Record individual game in history
            deck.matchups[oppColors].history.push({
              id: `${timestamp}_${index}`,
              timestamp: timestamp + index, // Slight offset to maintain order
              result: isWin ? 'win' : 'loss',
              matchType: matchType,
              opponentColors: oppColors
            });
          });
        } else {
          // BO3/BO5: Track entire match against single opponent
          const opponentColors = opponentColorsByGame[0]; // Only one opponent for match
          if(!deck.matchups[opponentColors]){
            deck.matchups[opponentColors] = {wins:0, losses:0, history:[]};
          }
          if(!deck.matchups[opponentColors].history) deck.matchups[opponentColors].history = []; // Migrate old data

          deck.matchups[opponentColors].wins += wins;
          deck.matchups[opponentColors].losses += losses;

          // Record match in history (single entry for entire match)
          deck.matchups[opponentColors].history.push({
            id: `${timestamp}`,
            timestamp: timestamp,
            wins: wins,
            losses: losses,
            matchType: matchType,
            opponentColors: opponentColors
          });
        }
      }
    }
    // Check if player has extra games remaining
    if(player.extraGamesRemaining && player.extraGamesRemaining > 0){
      player.extraGamesRemaining--;
      if(player.extraGamesRemaining > 0){
        log(`${player.name} finished game. ${player.extraGamesRemaining} extra game(s) remaining.`);
        evt.currentRun=null;
        finishOverlay.classList.remove('show');
        finishSaveBtn.disabled = false;
        // Show them in the finish prompt again for next game
        setTimeout(()=> finishRunPrompt(player), 100);
        renderLeaderboard();
        saveAll();
        return;
      }else{
        log(`${player.name} finished all extra games.`);
        delete player.extraGamesRemaining;
      }
    }
    // Convert colors to mana symbol icons
    const pipUrls = {
      'W': 'https://i.ibb.co/sJpHH9VZ/W.png',
      'U': 'https://i.ibb.co/0bPLHLk/U.png',
      'B': 'https://i.ibb.co/nM1ZZz3z/B.png',
      'R': 'https://i.ibb.co/NnjxnmZv/R.png',
      'G': 'https://i.ibb.co/tM5Mb1Q0/G.png',
      'C': 'https://i.ibb.co/xt4Lpn0X/C.png'
    };
    let colorDisplay = 'none';
    if(colors){
      const colorIcons = colors.split('').map(c =>
        pipUrls[c] ? `<img src="${pipUrls[c]}" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin:0 1px;" alt="${c}"/>` : c
      ).join('');
      colorDisplay = colorIcons;
    }
    let opponentDisplay = '';
    if(opponentColorsByGame.length > 0){
      if(matchType === 'BO1'){
        // Show each game's opponent for BO1
        const gameOppDisplays = opponentColorsByGame.map((oppColors, index) => {
          const oppColorIcons = oppColors.split('').map(c =>
            pipUrls[c] ? `<img src="${pipUrls[c]}" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin:0 1px;" alt="${c}"/>` : c
          ).join('');
          const gameLabel = index < wins ? `W${index + 1}` : `L${index - wins + 1}`;
          return `${gameLabel}:${oppColorIcons}`;
        }).join(', ');
        opponentDisplay = ` vs. [${gameOppDisplays}]`;
      } else {
        // Show single opponent for BO3/BO5
        const oppColors = opponentColorsByGame[0];
        const oppColorIcons = oppColors.split('').map(c =>
          pipUrls[c] ? `<img src="${pipUrls[c]}" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin:0 1px;" alt="${c}"/>` : c
        ).join('');
        opponentDisplay = ` vs. ${oppColorIcons}`;
      }
    }
    const themeName = colors ? getColorThemeName(colors) : '';
    const themeDisplay = themeName ? ` (Theme ${themeName})` : '';
    log(`Reported run for ${player.name}: ${wins}W/${losses}L (${matchesPlayed} matches), ${colorDisplay}${themeDisplay}${opponentDisplay}, type=${matchType}`);

    // Store player info for requeue and bonus overlays
    evt.currentRun.player = player;
    evt.currentRun.bonusHits = evt.currentRun.bonusHits || 3;

    finishOverlay.classList.remove('show');
    finishSaveBtn.disabled = false;

    // Clear unreported game flag
    hasUnreportedGame = false;
    unreportedGamePlayer = null;

    renderLeaderboard();
    saveAll();

    // Show requeue overlay
    requeuePlayerName.textContent = player.name;
    requeueOverlay.classList.add('show');
  });

  // Requeue overlay handlers
  requeueYesBtn.addEventListener('click', () => {
    const evt = currentEvent();
    if(!evt.currentRun || !evt.currentRun.player) return;

    const player = evt.currentRun.player;
    const bonusHits = evt.currentRun.bonusHits || 3;
    requeueOverlay.classList.remove('show');

    // Check if bonus overlay should be shown (4 or 5 symbols)
    if(bonusHits === 4 || bonusHits === 5){
      bonusPlayerName.textContent = player.name;
      bonusHitCount.textContent = bonusHits;
      bonusRewardOverlay.classList.add('show');
    } else {
      // No bonus, just requeue with base tickets
      for(let i=0;i<5;i++){
        player.tickets[i] = 1;
      }
      player.sparks = 0;
      player.createdAt = Date.now();
      clampPlayer(player);
      log(`${player.name} re-added to queue with 1 ticket per reel.`);

      // When winner re-enters, double all other active players' tickets (patience reward)
      const isIgnitedWin = currentWinnerMeta && currentWinnerMeta.reason === 'ignited';
      if(!isIgnitedWin){
        for(const other of evt.players){
          if(other.id === player.id) continue;
          if(other.status !== 'active') continue;
          doubleTicketsAllReels(other);
        }
        log(`All other players' tickets doubled (patience reward).`);
      }

      evt.currentRun = null;
      renderLeaderboard();
      saveAll();
    }
  });

  requeueNoBtn.addEventListener('click', () => {
    const evt = currentEvent();
    if(!evt.currentRun || !evt.currentRun.player) return;

    const player = evt.currentRun.player;
    requeueOverlay.classList.remove('show');

    player.status = 'afk';
    log(`${player.name} marked as AFK.`);

    evt.currentRun = null;
    renderLeaderboard();
    saveAll();
  });

  // Bonus reward overlay handler
  bonusConfirmBtn.addEventListener('click', () => {
    const evt = currentEvent();
    if(!evt.currentRun || !evt.currentRun.player) return;

    const player = evt.currentRun.player;
    const bonusHits = evt.currentRun.bonusHits || 3;
    const bonus = bonusHits >= 5 ? 2 : bonusHits === 4 ? 1 : 0;

    // Get selected bonus choice
    const activeChoice = bonusChoice.querySelector('.queue-chip.active');
    const choice = activeChoice ? activeChoice.dataset.choice : 'tickets';

    bonusRewardOverlay.classList.remove('show');

    if(choice === 'games'){
      // Extra games
      player.extraGamesRemaining = bonus;
      log(`${player.name} chose extra games bonus: ${bonus} additional game(s)`);

      // Still need to requeue them for now
      for(let i=0;i<5;i++){
        player.tickets[i] = 1;
      }
      player.sparks = 0;
      player.createdAt = Date.now();
      clampPlayer(player);
      log(`${player.name} re-added to queue with 1 ticket per reel.`);

      // Double other players' tickets
      const isIgnitedWin = currentWinnerMeta && currentWinnerMeta.reason === 'ignited';
      if(!isIgnitedWin){
        for(const other of evt.players){
          if(other.id === player.id) continue;
          if(other.status !== 'active') continue;
          doubleTicketsAllReels(other);
        }
        log(`All other players' tickets doubled (patience reward).`);
      }
    } else {
      // Bonus tickets
      const baseTickets = 1 + bonus;
      for(let i=0;i<5;i++){
        let newTickets = baseTickets;
        if(newTickets > TICKET_CAP){
          const overflow = newTickets - TICKET_CAP;
          newTickets = TICKET_CAP;
          applyOverflowToSparks(player, overflow);
        }
        player.tickets[i] = newTickets;
      }
      player.sparks = 0;
      player.createdAt = Date.now();
      clampPlayer(player);
      log(`${player.name} re-added to queue with ${baseTickets} ticket(s) per reel (bonus included).`);

      // Double other players' tickets
      const isIgnitedWin = currentWinnerMeta && currentWinnerMeta.reason === 'ignited';
      if(!isIgnitedWin){
        for(const other of evt.players){
          if(other.id === player.id) continue;
          if(other.status !== 'active') continue;
          doubleTicketsAllReels(other);
        }
        log(`All other players' tickets doubled (patience reward).`);
      }
    }

    evt.currentRun = null;
    renderLeaderboard();
    saveAll();
  });

  function performSpin(){
    const evt = currentEvent();

    // Reset sort to default (highest probability at top)
    currentSortColumn = 'total';
    currentSortDirection = 'desc';

    // Check for unreported game before allowing spin
    if(hasUnreportedGame && unreportedGamePlayer){
      smallStatus.textContent = "Please report previous game results first.";
      log(`<span style="color:var(--gold);"> Unreported game detected - please report ${unreportedGamePlayer.name}'s results before spinning again.</span>`);
      finishRunPrompt(unreportedGamePlayer);
      return;
    }

    if(evt.currentRun){
      smallStatus.textContent = "Finish current run before next spin.";
      finishOverlay.classList.add('show');
      return;
    }

    // Update ignition queue with any players at 12 sparks
    updateIgnitionQueue(evt);

    // Check if we can process an ignition this spin (cooldown check)
    if(canTriggerIgnition(evt)){
      const ignitedPlayer = processIgnitionQueue(evt);
      if(ignitedPlayer){
        const activeCount = evt.players.filter(p=>p.status==='active').length;
        const cooldown = getIgnitionCooldown(activeCount);
        const queueLength = ignitedQueue.length;
        log(`<span style="color:#fcd34d;font-weight:600;">${ignitedPlayer.name} has been Ignited! (${ignitedPlayer.sparks} sparks, ${queueLength} in queue, cooldown: ${cooldown} spins)</span>`);
        // Start bulb celebration for ignited player
        startBulbsAnimation(false);
        setTimeout(()=>{
          stopBulbsAnimation();
          handleWinnerBanner(ignitedPlayer,'ignited',3,false);
        },1200);
        renderLeaderboard();
        saveAll();
        return;
      }
    }

    const activePlayers = evt.players.filter(p=>p.status==='active');
    if(activePlayers.length===0){
      smallStatus.textContent="No active players. Add someone first.";
      return;
    }

    // Dead spin guardrail - guarantee natural-looking win after too many dead spins
    // Add variance (1-2 spins) to prevent predictable patterns
    const baseMaxDeadStreak = getMaxDeadStreakAllowed(activePlayers.length);
    const variance = activePlayers.length <= 15 ? 1 : 2; // Larger groups get more variance
    const maxDeadStreak = baseMaxDeadStreak + Math.floor(Math.random() * (variance * 2 + 1)) - variance;
    const guaranteeWin = evt.deadSpinStreak >= maxDeadStreak;

    spinBtn.disabled=true;
    leverEl.classList.add('pull');
    spinAnimationStart();
    smallStatus.textContent="Spinning";

    // Build spin result immediately (for timing calculation)
    const symbols = buildSpinResult(evt, guaranteeWin, false);
    const isCarlo = detectCarlo(symbols);
    let isLunaWin = false;
    const lunaPick = detectLunaWinner(evt,symbols);
    if(lunaPick) isLunaWin = true;
    const hasWinner = isCarlo || lunaPick || detectHitWinner(evt,symbols);

    // Start bulb animation immediately if there's a winner
    if(hasWinner){
      startBulbsAnimation(isLunaWin);
    }

    // Use cascading reel stops with callback when all reels finish
    spinAnimationStopCascade(() => {
      leverEl.classList.remove('pull');
      renderSpinResult(symbols);

      // Log Luna appearances (regardless of win/loss)
      const lunaCount = symbols.filter(s => s.type === 'luna').length;
      if(lunaCount > 0){
        log(`<span style="color:#f973fa;font-weight:600;">Luna has appeared</span>`);
      }

      const reelPlayers=[];
      symbols.forEach((s,idx)=>{
        if(s.type==='player') reelPlayers.push({index:idx,playerId:s.playerId});
      });
      let winner=null;
      let reason='normal';
      let hits=3;
      if(isCarlo){
        // CoAST: Bulbs already running, wait a bit more then show banner
        setTimeout(()=>{
          stopBulbsAnimation();
          evt.carloHits++;
          winnerOverlay.classList.add('show');
          winnerHeading.textContent='CoAST!';
          winnerNameEl.textContent='CoAST';
          winnerMetaEl.textContent='Streamer plays their own deck this round.';
          winnerLunaSticker.style.display='none';
          pendingWinner=null;
          currentWinnerMeta={reason:'carlo',hits:0};
          evt.spinCount++;
          evt.deadSpinStreak=0;
          evt.lastSpinWasWinner=true;
          renderLeaderboard();
          saveAll();
          spinBtn.disabled=false;
          smallStatus.textContent="Ready.";
        },200); // Short delay after last reel stops
        return;
      }
      if(lunaPick){
        winner = lunaPick.player;
        reason='luna';
        hits = lunaPick.hits;
        isLunaWin=true;
        evt.lunaHits++;
      }else{
        const hit = detectHitWinner(evt,symbols);
        if(hit){
          winner = hit.player;
          reason='normal';
          hits = hit.hits;
        }
      }
      if(winner){
        // Winner found: Bulbs already running, handle tickets then show banner
        handleWinTickets(evt,winner,symbols,reelPlayers);
        // Color code: pink for Luna wins, green for regular wins
        const winColor = isLunaWin ? '#f973fa' : '#22c55e';
        log(`<span style="color:${winColor};font-weight:600;">${winner.name} wins the slot (${reason}, hits=${hits}).</span>`);
        // Short delay after last reel stops before showing winner banner
        setTimeout(()=>{
          stopBulbsAnimation();
          handleWinnerBanner(winner,reason,hits,isLunaWin);
          spinBtn.disabled=false;
          smallStatus.textContent="Ready.";
        },200);
      }else{
        // Dead spin: No bulb celebration
        evt.deadSpinStreak++;
        evt.lastSpinWasWinner = false;
        log(`<span style="color:var(--red);">Dead spin (#${evt.deadSpinStreak}).</span>`);
        handleDeadSpinTickets(evt,symbols,reelPlayers);
        spinBtn.disabled=false;
        smallStatus.textContent="Ready.";
      }
      evt.spinCount++;
      renderLeaderboard();
      saveAll();
    });
  }

  spinBtn.addEventListener('click',performSpin);
  leverEl.addEventListener('click',performSpin);

  addPlayerForm.addEventListener('submit',e=>{
    e.preventDefault();
    e.stopPropagation();

    // Grab value FIRST
    const nameToAdd = playerNameInput.value.trim();

    // Immediately clear
    playerNameInput.value = '';

    // Add player if there's a name
    if(nameToAdd){
      addPlayer(nameToAdd);
    }

    // Ensure focus stays for next entry
    setTimeout(() => {
      playerNameInput.focus();
    }, 0);

    return false;
  });

  helpBtn.addEventListener('click',()=>helpOverlay.classList.add('show'));
  closeHelpBtn.addEventListener('click',()=>{helpOverlay.classList.remove('show');saveAll();});
  diagBtn.addEventListener('click',()=>diagOverlay.classList.add('show'));
  closeDiagBtn.addEventListener('click',()=>{diagOverlay.classList.remove('show');saveAll();});
  exportBtn.addEventListener('click',()=>{
    const exportData = {
      version: '1.0',
      exportDate: new Date().toISOString(),
      state: state,
      theme: document.body.className
    };
    const dataStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `carlo-slot-session-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    log('Session exported successfully.');
  });

  importBtn.addEventListener('click',()=>{
    importFileInput.click();
  });

  importFileInput.addEventListener('change',e=>{
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = evt=>{
      try{
        const imported = JSON.parse(evt.target.result);
        if(!imported.state){
          alert('Invalid import file: missing state data.');
          return;
        }
        if(!confirm('Import will replace ALL current data. Continue?')) return;
        state.events = imported.state.events || [];
        state.currentEventIndex = imported.state.currentEventIndex || 1;
        if(imported.theme){
          const themeMatch = imported.theme.match(/theme-(white|blue|black|red|green)/);
          if(themeMatch){
            const colorMap = {white:'W',blue:'U',black:'B',red:'R',green:'G'};
            applyTheme(colorMap[themeMatch[1]]);
          }
        }
        logEl.innerHTML = ''; // Clear history log before import
        log('Session imported successfully.');
        renderEvents();
        renderLeaderboard();
        saveAll();
      }catch(err){
        alert('Import failed: ' + err.message);
      }
    };
    reader.readAsText(file);
    importFileInput.value = '';
  });

  // Factory Reset - Show modal
  resetEventBtn.addEventListener('click',()=>{
    factoryResetInput.value = '';
    factoryResetConfirmBtn.disabled = true;
    factoryResetConfirmBtn.style.opacity = '0.3';
    factoryResetConfirmBtn.style.cursor = 'not-allowed';
    factoryResetOverlay.classList.add('show');
  });

  // Factory Reset - Input validation
  factoryResetInput.addEventListener('input', (e) => {
    const isValid = e.target.value.toUpperCase() === 'RESET';
    factoryResetConfirmBtn.disabled = !isValid;
    factoryResetConfirmBtn.style.opacity = isValid ? '1' : '0.3';
    factoryResetConfirmBtn.style.cursor = isValid ? 'pointer' : 'not-allowed';
  });

  // Factory Reset - Cancel
  factoryResetCancelBtn.addEventListener('click', () => {
    factoryResetOverlay.classList.remove('show');
  });

  // Factory Reset - Confirm and execute
  factoryResetConfirmBtn.addEventListener('click', () => {
    if(factoryResetInput.value.toUpperCase() !== 'RESET') return;

    // Clear all commanderPod localStorage keys
    const keysToRemove = [];
    for(let i = 0; i < localStorage.length; i++){
      const key = localStorage.key(i);
      if(key && key.startsWith('commanderPod_')){
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));

    // Reset in-memory state
    state.events[state.currentEventIndex]={
      players:[],
      spinCount:0,
      deadSpinStreak:0,
      currentRun:null,
      carloHits:0,
      lunaHits:0
    };
    logEl.innerHTML = ''; // Clear history log

    // Set factory reset flag
    localStorage.setItem('commanderPod_factory_reset', Date.now().toString());

    log('Factory reset complete. Reloading...');
    factoryResetOverlay.classList.remove('show');

    // Force reload to ensure clean slate
    setTimeout(() => window.location.reload(), 500);
  });

  runDiagNowBtn.addEventListener('click',()=>{
    const evt = currentEvent();
    const players = evt.players.filter(p=>p.status==='active');
    if(players.length===0){
      diagResult.innerHTML='<span class="warn">No active players. Add some before running diagnostics.</span>';
      return;
    }
    const sim = runDiagnosticsSimulation(evt,300);
    // Dynamic thresholds based on player count and dead spin guardrails
    const playerCount = players.length;
    const maxDeadStreak = getMaxDeadStreakAllowed(playerCount);

    // Expected wins: With faster ticket growth, expect more natural wins + guardrail baseline
    // For 20-25 players: maxDeadStreak=7, so ~42 guardrail wins + natural wins = ~50-60 total
    const minWinsFromGuardrail = Math.floor(300 / maxDeadStreak);
    const expectedWins = Math.max(30, Math.floor(minWinsFromGuardrail * 1.3)); // 30% buffer for natural wins

    const expectedCarlos = 0; // CoAST is extremely rare - bonus jackpot, not balance requirement
    const expectedLuna = Math.max(3, Math.floor(playerCount * 0.2)); // Reduced from 0.25
    const expectedFourKind = Math.max(1, Math.floor(playerCount * 0.12)); // Increased for better scaling
    const expectedFiveKind = playerCount <= 15 ? 0 : 1; // Only expect 5oak with larger groups

    const passWins = sim.wins >= expectedWins;
    const passCarlo = sim.carlo >= expectedCarlos; // Always pass - CoAST is a bonus jackpot
    const passLuna = sim.luna >= expectedLuna;
    const passFourKind = sim.fourKind >= expectedFourKind;
    const passFiveKind = sim.fiveKind >= expectedFiveKind;
    const ignitedRate = (sim.ignitedWins / 300 * 100).toFixed(1);
    const passIgnited = sim.ignitedWins <= 30; // Less than 10% is good
    const allPass = passWins && passCarlo && passLuna && passFourKind && passFiveKind && passIgnited;
    diagResult.innerHTML = `
      <div><strong>Simulated 300 spins (Hypergeometric):</strong></div>
      <div>Total wins: ${sim.wins} ${passWins?'<span class="pass">('+expectedWins+' )</span>':'<span class="warn">(Need '+expectedWins+')</span>'}</div>
      <div>CoAST jackpots: ${sim.carlo} ${passCarlo?'<span class="pass">('+expectedCarlos+' )</span>':'<span class="warn">(Need '+expectedCarlos+')</span>'}</div>
      <div>Luna Luck wins: ${sim.luna} ${passLuna?'<span class="pass">('+expectedLuna+' )</span>':'<span class="warn">(Need '+expectedLuna+')</span>'}</div>
      <div>4-of-a-kind: ${sim.fourKind} ${passFourKind?'<span class="pass">('+expectedFourKind+' )</span>':'<span class="warn">(Need '+expectedFourKind+')</span>'}</div>
      <div>5-of-a-kind: ${sim.fiveKind} ${passFiveKind?'<span class="pass">('+expectedFiveKind+' )</span>':'<span class="warn">(Need '+expectedFiveKind+')</span>'}</div>
      <div>Ignited wins: ${sim.ignitedWins} (${ignitedRate}%) ${passIgnited?'<span class="pass">(10% )</span>':'<span class="warn">(>10% - too many)</span>'}</div>
      <div style="margin-top:8px;font-weight:700;">${allPass?'<span class="pass">All checks PASSED </span>':'<span class="warn">Some checks FAILED</span>'}</div>
    `;
  });

  function runDiagnosticsSimulation(evt, spins){
    const players = evt.players.filter(p=>p.status==='active').map(p=>{
      return {
        name:p.name,
        tickets:p.tickets.slice(),
        sparks:p.sparks,
        createdAt:p.createdAt
      };
    });
    function randomPlayer(idx, arr){
      let tot=0;
      arr.forEach(p=>tot+=p.tickets[idx]);
      const r=Math.random()*tot;
      let x=r;
      for(const p of arr){
        if(x < p.tickets[idx]) return p;
        x -= p.tickets[idx];
      }
      return arr[arr.length-1];
    }
    function normTickets(){
      players.forEach(p=>{
        const tot=totalTickets(p);
        if(tot===0) p.tickets=[1,1,1,1,1];
      });
    }
    normTickets();
    let wins=0, carlo=0, luna=0, fourKind=0, fiveKind=0, ignitedWins=0;
    for(let spin=0;spin<spins;spin++){
      const candIgnited = players.filter(p=>p.sparks>=MAX_SPARKS);
      if(candIgnited.length>0){
        candIgnited.sort((a,b)=>{
          if(a.createdAt !== b.createdAt) return a.createdAt - b.createdAt;
          if(b.sparks !== a.sparks) return b.sparks - a.sparks;
          const td = totalTickets(b) - totalTickets(a);
          return td !== 0 ? td : a.name.localeCompare(b.name);
        });
        const p = candIgnited[0];
        wins++;ignitedWins++;p.sparks=0;
        continue;
      }
      const active = players.slice();
      const symbols=[];
      let lunaIndex=-1;
      // Use dynamic odds based on active player count
      const lunaOdds = getLunaBaseOdds(active.length);
      const carloLetterOdds = getCarloLetterOdds(active.length);
      if(Math.random() < lunaOdds){
        lunaIndex=Math.floor(Math.random()*5);
      }
      const letters=['C','A','R','L','O'];
      for(let i=0;i<5;i++){
        if(i===lunaIndex){symbols.push({type:'luna'});continue;}
        if(Math.random() < carloLetterOdds){
          symbols.push({type:'letter',letter:letters[i]});
        }else{
          const p = randomPlayer(i,active);
          symbols.push({type:'player',name:p.name});
        }
      }
      if(symbols.every((s,i)=>s.type==='letter' && s.letter===letters[i])){carlo++;continue;}
      let lunaWinner=null;
      if(lunaIndex!==-1){
        for(let i=-2;i<=0;i++){
          const idx=lunaIndex+i;
          if(idx<0||idx+2>=5) continue;
          const triple=symbols.slice(idx,idx+3);
          const ps=triple.filter(x=>x.type==='player');
          if(ps.length===0) continue;
          const cts={};ps.forEach(x=>cts[x.name]=(cts[x.name]||0)+1);
          const candidate=Object.keys(cts).find(n=>cts[n]>=2);
          if(candidate){
            lunaWinner=candidate;break;
          }else if(ps.length===1){
            lunaWinner=ps[0].name;break;
          }
        }
      }
      if(lunaWinner){luna++;wins++;continue;}
      const hits={};
      let hitPlayer=null;let hitCount=0;
      symbols.forEach(s=>{
        if(s.type==='player'){
          hits[s.name]=(hits[s.name]||0)+1;
          if(hits[s.name]>hitCount){
            hitPlayer=s.name;
            hitCount=hits[s.name];
          }
        }
      });
      if(hitCount>=3){
        wins++;
        if(hitCount===4) fourKind++;
        if(hitCount===5) fiveKind++;
      }
    }
    return {wins, carlo, luna, fourKind, fiveKind, ignitedWins};
  }

  function toggleThemeColor(code){
    if(selectedColors.has(code)){
      selectedColors.delete(code);
      // Allow no colors selected - removes all glows
    }else{
      selectedColors.add(code);
    }
    applyMultiTheme();
  }

  function applyMultiTheme(){
    // Remove old theme classes
    const classes = ['theme-white','theme-blue','theme-black','theme-red','theme-green','theme-gold'];
    document.body.classList.remove(...classes);

    // If no colors selected, Luna mode (no theme class needed, gradient handles it)
    if(selectedColors.size === 0){
      // Luna mode - no theme class, gradients applied in applyGradientGlow()
    }
    // If all 5 colors selected, use gold
    else if(selectedColors.size === 5){
      document.body.classList.add('theme-gold');
    }else{
      // Use the first selected color as primary theme
      const primary = Array.from(selectedColors)[0];
      let cls='';
      if(primary==='W') cls='theme-white';
      else if(primary==='U') cls='theme-blue';
      else if(primary==='B') cls='theme-black';
      else if(primary==='R') cls='theme-red';
      else if(primary==='G') cls='theme-green';
      if(cls) document.body.classList.add(cls);
    }

    // Update active chips
    themeChips.forEach(ch=>{
      ch.classList.toggle('active', selectedColors.has(ch.dataset.color));
    });

    // Apply animated gradient glow
    applyGradientGlow();

    // Save to localStorage
    localStorage.setItem('carlo_theme_multi', JSON.stringify(Array.from(selectedColors)));
    saveAll();
  }

  // MTG Color Identity Mappings - Proper ordering for all combinations
  // Theme gradient colors for animated borders (visible colors)
  const COLOR_HEX = {
    'W': '#fefce8',  // White/cream
    'U': '#38bdf8',  // Blue
    'B': '#c084fc',  // Purple (B theme color)
    'R': '#fb4b4b',  // Red
    'G': '#22c55e'   // Green
  };

  // Shadow colors for independent moving shadow animation layer
  const SHADOW_HEX = {
    'W': '#ffffff',  // White shadow
    'U': '#0ea5e9',  // Blue shadow (darker)
    'B': '#000000',  // Black shadow
    'R': '#dc2626',  // Red shadow (darker)
    'G': '#16a34a'   // Green shadow (darker)
  };

  const MTG_COLOR_ORDERS = {
    // Mono (5)
    'W': ['W'],
    'U': ['U'],
    'B': ['B'],
    'R': ['R'],
    'G': ['G'],
    // Dual (10) - Allied pairs
    'WU': ['W','U'], // Azorius
    'UB': ['U','B'], // Dimir
    'BR': ['B','R'], // Rakdos
    'RG': ['R','G'], // Gruul
    'GW': ['G','W'], // Selesnya
    // Dual - Enemy pairs
    'WB': ['W','B'], // Orzhov
    'UR': ['U','R'], // Izzet
    'BG': ['B','G'], // Golgari
    'WR': ['W','R'], // Boros
    'UG': ['U','G'], // Simic
    // Triple (10) - Shards
    'GWU': ['G','W','U'], // Bant
    'WUB': ['W','U','B'], // Esper
    'UBR': ['U','B','R'], // Grixis
    'BRG': ['B','R','G'], // Jund
    'RGW': ['R','G','W'], // Naya
    // Triple - Wedges
    'WBG': ['W','B','G'], // Abzan
    'URW': ['U','R','W'], // Jeskai
    'BGU': ['B','G','U'], // Sultai
    'RWB': ['R','W','B'], // Mardu
    'GUR': ['G','U','R'], // Temur
    // Four-color (5)
    'UBRG': ['U','B','R','G'],
    'BRGW': ['B','R','G','W'],
    'RGWU': ['R','G','W','U'],
    'GWUB': ['G','W','U','B'],
    'WUBR': ['W','U','B','R'],
    // Five-color (1)
    'WUBRG': ['W','U','B','R','G']
  };

  function getColorIdentityKey(colorSet){
    const sorted = Array.from(colorSet).sort((a,b)=>{
      const order = ['W','U','B','R','G'];
      return order.indexOf(a) - order.indexOf(b);
    });
    return sorted.join('');
  }

  function applyGradientGlow(){
    // No colors selected - activate Luna pink gradient mode (animates to black like mono-colored themes)
    if(selectedColors.size === 0){
      const lunaColor = '#f973fa'; // Luna's signature hot pink
      const lunaShadowColor = '#e91e8c'; // Darker pink for shadow layer
      const lunaGradient = `linear-gradient(90deg, ${lunaColor}, ${lunaColor}, #000000, #000000, ${lunaColor}, ${lunaColor})`;
      const lunaShadow = `linear-gradient(90deg, ${lunaShadowColor}, ${lunaShadowColor}, #000000, #000000, ${lunaShadowColor}, ${lunaShadowColor})`;
      document.documentElement.style.setProperty('--multi-theme-gradient', lunaGradient);
      document.documentElement.style.setProperty('--gradient-border', lunaGradient);
      document.documentElement.style.setProperty('--gradient-shadow', lunaShadow);
      document.documentElement.style.setProperty('--gradient-border-size', '200%');
      document.documentElement.style.setProperty('--logo-ring-gradient', `conic-gradient(from 0deg, ${lunaColor} 0deg 60deg, transparent 60deg 120deg, ${lunaColor} 120deg 180deg, transparent 180deg 240deg, ${lunaColor} 240deg 300deg, transparent 300deg 360deg)`);
      document.documentElement.style.setProperty('--theme-glow', 'rgba(249, 115, 250, 0.5)');
      document.documentElement.style.setProperty('--theme-color', lunaColor);
      document.documentElement.style.setProperty('--button-text-color', '#ffffff');
      document.documentElement.style.setProperty('--button-text-is-gradient', '0');
      return;
    }

    // Get the proper MTG color order for this combination
    const identityKey = getColorIdentityKey(selectedColors);
    const colorOrder = MTG_COLOR_ORDERS[identityKey] || Array.from(selectedColors);
    const colors = colorOrder.map(code => COLOR_HEX[code]);
    const shadows = colorOrder.map(code => SHADOW_HEX[code]);

    // All 5 selected = gold with WUBRG order
    if(selectedColors.size === 5){
      const allColors = colors.join(', ');
      const allShadows = shadows.join(', ');
      document.documentElement.style.setProperty('--multi-theme-gradient', '#fcd34d');
      document.documentElement.style.setProperty('--gradient-border', `linear-gradient(90deg, ${allColors}, ${allColors})`);
      document.documentElement.style.setProperty('--gradient-shadow', `linear-gradient(90deg, ${allShadows}, ${allShadows})`);
      document.documentElement.style.setProperty('--gradient-border-size', '200%');
      document.documentElement.style.setProperty('--button-text-color', `linear-gradient(90deg, ${allColors})`);
      document.documentElement.style.setProperty('--button-text-is-gradient', '1');
      const segments = colors.map((c, i) => {
        const start = i * 72;
        const end = start + 36;
        return `${c} ${start}deg ${end}deg, transparent ${end}deg ${(i + 1) * 72}deg`;
      }).join(', ');
      document.documentElement.style.setProperty('--logo-ring-gradient', `conic-gradient(from 0deg, ${segments})`);
      return;
    }

    // Non-gold mode: white text for buttons
    document.documentElement.style.setProperty('--button-text-color', '#ffffff');
    document.documentElement.style.setProperty('--button-text-is-gradient', '0');

    // Create animated gradient with proper MTG color order
    if(colors.length > 1){
      const gradient = `linear-gradient(90deg, ${colors.join(', ')}, ${colors.join(', ')})`;
      const shadowGradient = `linear-gradient(90deg, ${shadows.join(', ')}, ${shadows.join(', ')})`;
      document.documentElement.style.setProperty('--multi-theme-gradient', gradient);
      document.documentElement.style.setProperty('--gradient-border', gradient);
      document.documentElement.style.setProperty('--gradient-shadow', shadowGradient);
      document.documentElement.style.setProperty('--gradient-border-size', '200%');
    } else {
      // Mono-colored theme: animate from theme color to black and back
      const singleColorGradient = `linear-gradient(90deg, ${colors[0]}, ${colors[0]}, #000000, #000000, ${colors[0]}, ${colors[0]})`;
      const singleShadowGradient = `linear-gradient(90deg, ${shadows[0]}, ${shadows[0]}, #000000, #000000, ${shadows[0]}, ${shadows[0]})`;
      document.documentElement.style.setProperty('--multi-theme-gradient', singleColorGradient);
      document.documentElement.style.setProperty('--gradient-border', singleColorGradient);
      document.documentElement.style.setProperty('--gradient-shadow', singleShadowGradient);
      document.documentElement.style.setProperty('--gradient-border-size', '200%');
    }

    // Create conic gradient for logo ring
    if(colors.length > 1){
      const segments = colors.map((c, i) => {
        const degreesPerColor = 360 / colors.length;
        const start = i * degreesPerColor;
        const end = start + (degreesPerColor / 2);
        return `${c} ${start}deg ${end}deg, transparent ${end}deg ${(i + 1) * degreesPerColor}deg`;
      }).join(', ');
      document.documentElement.style.setProperty('--logo-ring-gradient', `conic-gradient(from 0deg, ${segments})`);
    } else {
      document.documentElement.style.setProperty('--logo-ring-gradient', `conic-gradient(from 0deg,
        ${colors[0]} 0deg 60deg,
        transparent 60deg 120deg,
        ${colors[0]} 120deg 180deg,
        transparent 180deg 240deg,
        ${colors[0]} 240deg 300deg,
        transparent 300deg 360deg)`);
    }
  }

  themeChips.forEach(ch=>{
    ch.addEventListener('click',()=>toggleThemeColor(ch.dataset.color));
  });

  function loadTheme(){
    const saved = localStorage.getItem('carlo_theme_multi');
    if(saved){
      try{
        selectedColors = new Set(JSON.parse(saved));
      }catch(e){
        selectedColors = new Set(); // Empty = white glow default
      }
    }else{
      // Migrate old single-color theme
      const oldSaved = localStorage.getItem('carlo_theme');
      if(oldSaved){
        selectedColors = new Set([oldSaved]);
      }else{
        // Default to white glow (no theme selected)
        selectedColors = new Set();
      }
    }
    applyMultiTheme();
  }

  function init(){
    // Check if factory reset was just performed
    const resetFlag = localStorage.getItem('commanderPod_factory_reset');
    if(resetFlag){
      localStorage.removeItem('commanderPod_factory_reset');
      // Skip session check, start fresh
      initBulbs();
      setupReelsPlaceholder();
      renderEvents();
      renderLeaderboard();
      loadTheme();
      timeTimer = setInterval(renderLeaderboard, 30000);
      return;
    }

    // Check for existing session
    const sessionState = localStorage.getItem('commanderPod_session_state');
    const hasExistingData = localStorage.getItem('carlo_slot_events');

    if(sessionState === 'active' && hasExistingData){
      // Show resume prompt
      sessionResumeOverlay.classList.add('show');
    }else{
      // Start normally
      loadAll();
      initBulbs();
      setupReelsPlaceholder();
      renderEvents();
      renderLeaderboard();
      loadTheme();
      timeTimer = setInterval(renderLeaderboard, 30000);
      // Mark session as active
      localStorage.setItem('commanderPod_session_state', 'active');
    }
  }

  // Session resume handler
  sessionResumeBtn.addEventListener('click', () => {
    sessionResumeOverlay.classList.remove('show');
    loadAll();
    initBulbs();
    setupReelsPlaceholder();
    renderEvents();
    renderLeaderboard();
    loadTheme();
    timeTimer = setInterval(renderLeaderboard, 30000);
    log('Session resumed.');
  });

  // Session new handler
  sessionNewBtn.addEventListener('click', () => {
    sessionResumeOverlay.classList.remove('show');
    // Clear existing data
    localStorage.removeItem('carlo_slot_events');
    localStorage.removeItem('carlo_theme_multi');
    // Start fresh
    initBulbs();
    setupReelsPlaceholder();
    renderEvents();
    renderLeaderboard();
    loadTheme();
    timeTimer = setInterval(renderLeaderboard, 30000);
    localStorage.setItem('commanderPod_session_state', 'active');
    log('New session started.');
  });

  init();
})();
</script>
</body>
</html>
